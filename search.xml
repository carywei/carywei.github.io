<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HIDRAW</title>
      <link href="/2020/02/28/2020/0228/hidraw/"/>
      <url>/2020/02/28/2020/0228/hidraw/</url>
      
        <content type="html"><![CDATA[<p>hidraw设备主要用途，然后简要分析hidraw设备驱动，最后分析用户空间接口并实例。</p><h2 id="Hidraw介绍"><a href="#Hidraw介绍" class="headerlink" title="Hidraw介绍"></a>Hidraw介绍</h2><p>在内核<a href="https://elixir.bootlin.com/linux/latest/source/Documentation/hid/hidraw.rst" target="_blank" rel="noopener">Documentation/hid/hidraw.txt</a>中对hidraw设备进行介绍，以及和hiddev的区别。</p><p>hidraw提供了一个通过USB/Bluetooth接口的裸数据接口，它和hiddev的区别体现在数据不经过HID parse解析，而且直接数据传输。</p><blockquote><p>如果用户空间应用程序知道怎么恰当和硬件设备通信，和能够手动构建HID 报表，那么hidraw应该被使用。这通常是在用户控件驱动自定义HID 设备的时候。</p><p>Hidraw与不符合规范的HID 设备通信也是有利 的，这些设备以一种不符合报表描述符不一致的方式发送和接收数据。因为Hiddev解析器通过他发送和接收报表，检测设备的报表描述符，这样的通信是不可能使用hiddev。Hidraw是唯一的选择，为这些不兼容的设备编写一个定制的内核驱动程序。</p><p>Hidraw一个好处是用户空间应用程序使用独立的底层硬件类型。当前，hidraw是通过bluetooth 和 usb实现。在将来，随着硬件总线的发展，hidraw将支持更多的类型。</p></blockquote><p><img src="https://carywei.github.io/2020/02/28/2020/0228/hidraw/hidraw.png?raw=true" alt="img"></p><h2 id="Hidraw驱动"><a href="#Hidraw驱动" class="headerlink" title="Hidraw驱动"></a>Hidraw驱动</h2><ul><li>hidraw也是hid类设备</li></ul><pre><code>static int __init hid_init(void){    int ret;...        //注册总线hid_bus_type    ret = bus_register(&amp;hid_bus_type);...        //hidraw_init()被hid_init调用    ret = hidraw_init();    if (ret)        goto err_bus;        //创建/sys/kernel/debug/hid调试接口    hid_debug_init();...}static void __exit hid_exit(void){    hid_debug_exit();    hidraw_exit();    bus_unregister(&amp;hid_bus_type);}</code></pre><pre><code>struct hidraw {------------------------------&gt;struct hidraw是hidraw设备实例    unsigned int minor;----------------------&gt;从设备号。    int exist;-------------------------------&gt;表示设备是否连接。    int open;--------------------------------&gt;表示设备open计数。    wait_queue_head_t wait;    struct hid_device *hid;------------------&gt;对应hid设备实例。    struct device *dev;    spinlock_t list_lock;    struct list_head list;};struct hidraw_report {    __u8 *value;    int len;};struct hidraw_list {-------------------------&gt;是hidraw设备一次传输的实例。    struct hidraw_report buffer[HIDRAW_BUFFER_SIZE];    int head;    int tail;    struct fasync_struct *fasync;    struct hidraw *hidraw;    struct list_head node;    struct mutex read_mutex;};</code></pre><h2 id="Hid总线"><a href="#Hid总线" class="headerlink" title="Hid总线"></a>Hid总线</h2><pre><code>static struct bus_type hid_bus_type = {    .name          = &quot;hid&quot;,    .dev_groups    = hid_dev_groups,    .match         = hid_bus_match,    .probe         = hid_device_probe,    .remove        = hid_device_remove,    .uevent        = hid_uevent,};static int hid_uevent(struct device *dev, struct kobj_uevent_env *env){    struct hid_device *hdev = to_hid_device(dev);        if (add_uevent_var(env, &quot;HID_ID=%04X:%08X:%08X&quot;,            hdev-&gt;bus, hdev-&gt;vendor, hdev-&gt;product))        return -ENOMEM;    if (add_uevent_var(env, &quot;HID_NAME=%s&quot;, hdev-&gt;name))        return -ENOMEM;    if (add_uevent_var(env, &quot;HID_PHYS=%s&quot;, hdev-&gt;phys))        return -ENOMEM;    if (add_uevent_var(env, &quot;HID_UNIQ=%s&quot;, hdev-&gt;uniq))        return -ENOMEM;    if (add_uevent_var(env, &quot;MODALIAS=hid:b%04Xg%04Xv%08Xp%08X&quot;,               hdev-&gt;bus, hdev-&gt;group, hdev-&gt;vendor, hdev-&gt;product))        return -ENOMEM;    return 0;}</code></pre><h2 id="Hidraw初始化"><a href="#Hidraw初始化" class="headerlink" title="Hidraw初始化"></a>Hidraw初始化</h2><pre><code>int __init hidraw_init(void){    int result;    dev_t dev_id;        //从设备号0~63。    result = alloc_chrdev_region(&amp;dev_id, HIDRAW_FIRST_MINOR,            HIDRAW_MAX_DEVICES, &quot;hidraw&quot;);    if (result &lt; 0) {        pr_warn(&quot;can&#39;t get major number\n&quot;);        goto out;    }    hidraw_major = MAJOR(dev_id);        //创建hidraw设备类。    hidraw_class = class_create(THIS_MODULE, &quot;hidraw&quot;);    if (IS_ERR(hidraw_class)) {        result = PTR_ERR(hidraw_class);        goto error_cdev;    }    //初始化一个字符设备hidraw_dev，操作函数集为hidraw_ops。    cdev_init(&amp;hidraw_cdev, &amp;hidraw_ops);    result = cdev_add(&amp;hidraw_cdev, dev_id, HIDRAW_MAX_DEVICES);    if (result &lt; 0)        goto error_class;    printk(KERN_INFO &quot;hidraw: raw HID events driver (C) Jiri Kosina\n&quot;);out:    return result;error_class:    class_destroy(hidraw_class);error_cdev:    unregister_chrdev_region(dev_id, HIDRAW_MAX_DEVICES);    goto out;}void hidraw_exit(void){    dev_t dev_id = MKDEV(hidraw_major, 0);    cdev_del(&amp;hidraw_cdev);    class_destroy(hidraw_class);    unregister_chrdev_region(dev_id, HIDRAW_MAX_DEVICES);}</code></pre><h2 id="hidraw设备操作"><a href="#hidraw设备操作" class="headerlink" title="hidraw设备操作"></a>hidraw设备操作</h2><pre><code>static const struct file_operations hidraw_ops = {    .owner =        THIS_MODULE,    .read =         hidraw_read,    .write =        hidraw_write,    .poll =         hidraw_poll,    .open =         hidraw_open,    .release =      hidraw_release,    .unlocked_ioctl = hidraw_ioctl,    .fasync =    hidraw_fasync,#ifdef CONFIG_COMPAT    .compat_ioctl   = hidraw_ioctl,#endif    .llseek =    noop_llseek,};static ssize_t hidraw_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos){    struct hidraw_list *list = file-&gt;private_data;    int ret = 0, len;    DECLARE_WAITQUEUE(wait, current);    mutex_lock(&amp;list-&gt;read_mutex);    while (ret == 0) {        if (list-&gt;head == list-&gt;tail) {            add_wait_queue(&amp;list-&gt;hidraw-&gt;wait, &amp;wait);            set_current_state(TASK_INTERRUPTIBLE);            while (list-&gt;head == list-&gt;tail) {                if (signal_pending(current)) {                    ret = -ERESTARTSYS;                    break;                }                if (!list-&gt;hidraw-&gt;exist) {                    ret = -EIO;                    break;                }                if (file-&gt;f_flags &amp; O_NONBLOCK) {                    ret = -EAGAIN;                    break;                }                /* allow O_NONBLOCK to work well from other threads */                mutex_unlock(&amp;list-&gt;read_mutex);                schedule();                mutex_lock(&amp;list-&gt;read_mutex);                set_current_state(TASK_INTERRUPTIBLE);            }            set_current_state(TASK_RUNNING);            remove_wait_queue(&amp;list-&gt;hidraw-&gt;wait, &amp;wait);        }        if (ret)            goto out;        len = list-&gt;buffer[list-&gt;tail].len &gt; count ?            count : list-&gt;buffer[list-&gt;tail].len;        if (list-&gt;buffer[list-&gt;tail].value) {            if (copy_to_user(buffer, list-&gt;buffer[list-&gt;tail].value, len)) {                ret = -EFAULT;                goto out;            }            ret = len;        }        kfree(list-&gt;buffer[list-&gt;tail].value);        list-&gt;buffer[list-&gt;tail].value = NULL;        list-&gt;tail = (list-&gt;tail + 1) &amp; (HIDRAW_BUFFER_SIZE - 1);    }out:    mutex_unlock(&amp;list-&gt;read_mutex);    return ret;}static ssize_t hidraw_send_report(struct file *file, const char __user *buffer, size_t count, unsigned char report_type){    unsigned int minor = iminor(file_inode(file));    struct hid_device *dev;    __u8 *buf;    int ret = 0;    if (!hidraw_table[minor] || !hidraw_table[minor]-&gt;exist) {        ret = -ENODEV;        goto out;    }        //根据minor号找到对应hidraw设备的hid_device。    dev = hidraw_table[minor]-&gt;hid;...    buf = memdup_user(buffer, count);    if (IS_ERR(buf)) {        ret = PTR_ERR(buf);        goto out;    }    if ((report_type == HID_OUTPUT_REPORT) &amp;&amp;        !(dev-&gt;quirks &amp; HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP)) {        ret = hid_hw_output_report(dev, buf, count);        if (ret != -ENOSYS)            goto out_free;    }        //调用实际硬件接口发送report，比如usb、bluetooth等。    ret = hid_hw_raw_request(dev, buf[0], buf, count, report_type,                HID_REQ_SET_REPORT);out_free:    kfree(buf);out:    return ret;}static ssize_t hidraw_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos){    ssize_t ret;    mutex_lock(&amp;minors_lock);    ret = hidraw_send_report(file, buffer, count, HID_OUTPUT_REPORT);    mutex_unlock(&amp;minors_lock);    return ret;}static ssize_t hidraw_get_report(struct file *file, char __user *buffer, size_t count, unsigned char report_type){    unsigned int minor = iminor(file_inode(file));    struct hid_device *dev;    __u8 *buf;    int ret = 0, len;    unsigned char report_number;    dev = hidraw_table[minor]-&gt;hid;...    buf = kmalloc(count * sizeof(__u8), GFP_KERNEL);    if (!buf) {        ret = -ENOMEM;        goto out;    }    if (copy_from_user(&amp;report_number, buffer, 1)) {        ret = -EFAULT;        goto out_free;    }        //从硬件接口接收数据。    ret = hid_hw_raw_request(dev, report_number, buf, count, report_type,                 HID_REQ_GET_REPORT);...    if (copy_to_user(buffer, buf, len)) {        ret = -EFAULT;        goto out_free;    }    ret = len;out_free:    kfree(buf);out:    return ret;}static unsigned int hidraw_poll(struct file *file, poll_table *wait){    struct hidraw_list *list = file-&gt;private_data;    poll_wait(file, &amp;list-&gt;hidraw-&gt;wait, wait);    if (list-&gt;head != list-&gt;tail)        return POLLIN | POLLRDNORM;    if (!list-&gt;hidraw-&gt;exist)        return POLLERR | POLLHUP;    return 0;}static int hidraw_open(struct inode *inode, struct file *file){    unsigned int minor = iminor(inode);    struct hidraw *dev;    struct hidraw_list *list;    unsigned long flags;    int err = 0;    if (!(list = kzalloc(sizeof(struct hidraw_list), GFP_KERNEL))) {        err = -ENOMEM;        goto out;    }    mutex_lock(&amp;minors_lock);    if (!hidraw_table[minor] || !hidraw_table[minor]-&gt;exist) {        err = -ENODEV;        goto out_unlock;    }    dev = hidraw_table[minor];    if (!dev-&gt;open++) {        //调用底层设备即具体接口的power()函数，hdev-&gt;ll_driver-&gt;power()。        err = hid_hw_power(dev-&gt;hid, PM_HINT_FULLON);--------------        if (err &lt; 0) {            dev-&gt;open--;            goto out_unlock;        }                //调用底层设备的open()函数，hdev-&gt;ll_driver-&gt;open()。        err = hid_hw_open(dev-&gt;hid);        if (err &lt; 0) {            hid_hw_power(dev-&gt;hid, PM_HINT_NORMAL);            dev-&gt;open--;            goto out_unlock;        }    }    list-&gt;hidraw = hidraw_table[minor];    mutex_init(&amp;list-&gt;read_mutex);    spin_lock_irqsave(&amp;hidraw_table[minor]-&gt;list_lock, flags);    list_add_tail(&amp;list-&gt;node, &amp;hidraw_table[minor]-&gt;list);    spin_unlock_irqrestore(&amp;hidraw_table[minor]-&gt;list_lock, flags);    file-&gt;private_data = list;...}static int hidraw_fasync(int fd, struct file *file, int on){    struct hidraw_list *list = file-&gt;private_data;        //发送异步通知信号。    return fasync_helper(fd, file, on, &amp;list-&gt;fasync);}static void drop_ref(struct hidraw *hidraw, int exists_bit){    if (exists_bit) {        hidraw-&gt;exist = 0;        if (hidraw-&gt;open) {            hid_hw_close(hidraw-&gt;hid);            wake_up_interruptible(&amp;hidraw-&gt;wait);        }        device_destroy(hidraw_class,                   MKDEV(hidraw_major, hidraw-&gt;minor));    } else {            //打开计算减1。        --hidraw-&gt;open;    }    if (!hidraw-&gt;open) {//当计数为0后，开始释放资源。        if (!hidraw-&gt;exist) {            hidraw_table[hidraw-&gt;minor] = NULL;            kfree(hidraw);        } else {            /* close device for last reader */            hid_hw_power(hidraw-&gt;hid, PM_HINT_NORMAL);            hid_hw_close(hidraw-&gt;hid);        }    }}static int hidraw_release(struct inode * inode, struct file * file){    unsigned int minor = iminor(inode);    struct hidraw_list *list = file-&gt;private_data;    unsigned long flags;    mutex_lock(&amp;minors_lock);    spin_lock_irqsave(&amp;hidraw_table[minor]-&gt;list_lock, flags);    list_del(&amp;list-&gt;node);    spin_unlock_irqrestore(&amp;hidraw_table[minor]-&gt;list_lock, flags);    kfree(list);    drop_ref(hidraw_table[minor], 0);    mutex_unlock(&amp;minors_lock);    return 0;}static long hidraw_ioctl(struct file *file, unsigned int cmd,                            unsigned long arg){    struct inode *inode = file_inode(file);    unsigned int minor = iminor(inode);    long ret = 0;    struct hidraw *dev;    void __user *user_arg = (void __user*) arg;    mutex_lock(&amp;minors_lock);    dev = hidraw_table[minor];    if (!dev) {        ret = -ENODEV;        goto out;    }    switch (cmd) {        case HIDIOCGRDESCSIZE://Get report descriptor size。            if (put_user(dev-&gt;hid-&gt;rsize, (int __user *)arg))                ret = -EFAULT;            break;        case HIDIOCGRDESC://Get report descriptor。            {                __u32 len;                if (get_user(len, (int __user *)arg))                    ret = -EFAULT;                else if (len &gt; HID_MAX_DESCRIPTOR_SIZE - 1)                    ret = -EINVAL;                else if (copy_to_user(user_arg + offsetof(                    struct hidraw_report_descriptor,                    value[0]),                    dev-&gt;hid-&gt;rdesc,                    min(dev-&gt;hid-&gt;rsize, len)))                    ret = -EFAULT;                break;            }        case HIDIOCGRAWINFO://Get raw info，包括bus类型，vid和pid。            {                struct hidraw_devinfo dinfo;                dinfo.bustype = dev-&gt;hid-&gt;bus;                dinfo.vendor = dev-&gt;hid-&gt;vendor;                dinfo.product = dev-&gt;hid-&gt;product;                if (copy_to_user(user_arg, &amp;dinfo, sizeof(dinfo)))                    ret = -EFAULT;                break;            }        default:            {                struct hid_device *hid = dev-&gt;hid;                if (_IOC_TYPE(cmd) != &#39;H&#39;) {                    ret = -EINVAL;                    break;                }                                //Send a feature report。                if (_IOC_NR(cmd) == _IOC_NR(HIDIOCSFEATURE(0))) {                    int len = _IOC_SIZE(cmd);                    ret = hidraw_send_report(file, user_arg, len, HID_FEATURE_REPORT);                    break;                }                //Get a feature report。                if (_IOC_NR(cmd) == _IOC_NR(HIDIOCGFEATURE(0))) {                    int len = _IOC_SIZE(cmd);                    ret = hidraw_get_report(file, user_arg, len, HID_FEATURE_REPORT);                    break;                }                /* Begin Read-only ioctls. */                if (_IOC_DIR(cmd) != _IOC_READ) {                    ret = -EINVAL;                    break;                }                                //Get raw name。                if (_IOC_NR(cmd) == _IOC_NR(HIDIOCGRAWNAME(0))) {                    int len = strlen(hid-&gt;name) + 1;                    if (len &gt; _IOC_SIZE(cmd))                        len = _IOC_SIZE(cmd);                    ret = copy_to_user(user_arg, hid-&gt;name, len) ?                        -EFAULT : len;                    break;                }                                //Get physical address。                if (_IOC_NR(cmd) == _IOC_NR(HIDIOCGRAWPHYS(0))) {                    int len = strlen(hid-&gt;phys) + 1;                    if (len &gt; _IOC_SIZE(cmd))                        len = _IOC_SIZE(cmd);                    ret = copy_to_user(user_arg, hid-&gt;phys, len) ?                        -EFAULT : len;                    break;                }            }        ret = -ENOTTY;    }out:    mutex_unlock(&amp;minors_lock);    return ret;}</code></pre><p>由于一个系统下可能存在多个hidraw设备，常通过HIDIOCGRAWINFO获取信息，判断对应的hidraw设备。</p><pre><code>int hidraw_connect(struct hid_device *hid){    int minor, result;    struct hidraw *dev;    /* we accept any HID device, all applications */    dev = kzalloc(sizeof(struct hidraw), GFP_KERNEL);    if (!dev)        return -ENOMEM;    result = -EINVAL;    mutex_lock(&amp;minors_lock);    //分配hidraw设备的minor号，并将dev赋给hidraw_table[]。    for (minor = 0; minor &lt; HIDRAW_MAX_DEVICES; minor++) {        if (hidraw_table[minor])            continue;        hidraw_table[minor] = dev;        result = 0;        break;    }    if (result) {        mutex_unlock(&amp;minors_lock);        kfree(dev);        goto out;    }        //创建/dev/hidrawX设备节点。    dev-&gt;dev = device_create(hidraw_class, &amp;hid-&gt;dev, MKDEV(hidraw_major, minor),                 NULL, &quot;%s%d&quot;, &quot;hidraw&quot;, minor);    if (IS_ERR(dev-&gt;dev)) {        hidraw_table[minor] = NULL;        mutex_unlock(&amp;minors_lock);        result = PTR_ERR(dev-&gt;dev);        kfree(dev);        goto out;    }    init_waitqueue_head(&amp;dev-&gt;wait);    spin_lock_init(&amp;dev-&gt;list_lock);    INIT_LIST_HEAD(&amp;dev-&gt;list);    dev-&gt;hid = hid;    dev-&gt;minor = minor;    dev-&gt;exist = 1;    hid-&gt;hidraw = dev;    mutex_unlock(&amp;minors_lock);out:    return result;}EXPORT_SYMBOL_GPL(hidraw_connect);void hidraw_disconnect(struct hid_device *hid){    struct hidraw *hidraw = hid-&gt;hidraw;    mutex_lock(&amp;minors_lock);    drop_ref(hidraw, 1);    mutex_unlock(&amp;minors_lock);}EXPORT_SYMBOL_GPL(hidraw_disconnect);</code></pre><blockquote><p>所以hidraw的驱动分为两部分，一是hidraw_init()发起的整个hidraw设备驱动的初始化，二是底层驱动检测到hidraw设备后通过hidraw_connect()/hidraw_disconnect()创建或者销毁设备。</p><p>当USB/Bluetooth检查到设备是hidraw类型之后，就会调用hidraw提供的接口创建设备，表现为创建节点/dev/hidrawx。</p><p>后续用户空间程序对/dev/hidrawx进行read/write/ioctl等操作。</p></blockquote><h2 id="hidraw测试程序"><a href="#hidraw测试程序" class="headerlink" title="hidraw测试程序"></a>hidraw测试程序</h2><p>内核提供了一个示例程序 <a href="https://elixir.bootlin.com/linux/latest/source/samples/hidraw/hid-example.c" target="_blank" rel="noopener">hid-example.c</a> 下面结合内核代码简单分析一下。遍历/dev下所有的hidraw设备，然后读取信息。</p><pre><code>/* Linux */#include &lt;linux/types.h&gt;#include &lt;linux/input.h&gt;#include &lt;linux/hidraw.h&gt;#include &lt;dirent.h&gt;#ifndef HIDIOCSFEATURE#warning Please have your distro update the userspace kernel headers#define HIDIOCSFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, &#39;H&#39;, 0x06, len)#define HIDIOCGFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, &#39;H&#39;, 0x07, len)#endif/* Unix */#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;/* C */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;const char *bus_str(int bus);int main(int argc, char **argv){    int fd;    int i, res, desc_size = 0;    char buf[256];    struct hidraw_report_descriptor rpt_desc;    struct hidraw_devinfo info;    char device[32] = &quot;/dev/hidraw0&quot;;    DIR *dir = NULL;    struct dirent *ptr;    /* Open dir /dev. */    dir = opendir(&quot;/dev&quot;);    if(!dir) {        perror(&quot;Popen dir failed...&quot;);        return -ENOENT;    }    /* 遍历/dev目录下所有的文件。 */    while(ptr = readdir(dir)) {            //判断设备是否为字符设备，其他设备包括            //DT_UNKNOWN/DT_FIFO/DT_CHR DT_DIR/DT_BLK/DT_REG/DT_LNK/DT_SOCK/DT_WHT。        if(ptr-&gt;d_type != DT_CHR)            continue;if(!strncmp(ptr-&gt;d_name, &quot;hidraw&quot;, 6)) {            snprintf(device, sizeof(device), &quot;%s/%s&quot;, &quot;/dev&quot;, ptr-&gt;d_name);            /* Open the Device with non-blocking reads. In real life,               don&#39;t use a hard coded path; use libudev instead. */            //打开hidraw设备，对应内核的hidraw_open()。               fd = open(device, O_RDWR|O_NONBLOCK);            if (fd &lt; 0) {                printf(&quot;Unable to open device %s.\n&quot;, device);                return 1;            }            memset(&amp;rpt_desc, 0x0, sizeof(rpt_desc));            memset(&amp;info, 0x0, sizeof(info));            memset(buf, 0x0, sizeof(buf));            printf(&quot;\n\n=================================Device %s info=================================\n&quot;, device);            /* Get Raw Name */            //对应hidraw_ioctl()的HIDIOCGRAWNAME。            res = ioctl(fd, HIDIOCGRAWNAME(256), buf);            if (res &lt; 0)                perror(&quot;HIDIOCGRAWNAME&quot;);            else                printf(&quot;Raw Name: %s\n&quot;, buf);            /* Get Physical Location */            //对应HIDIOCGRAWPHYS。            res = ioctl(fd, HIDIOCGRAWPHYS(256), buf);            if (res &lt; 0)                perror(&quot;HIDIOCGRAWPHYS&quot;);            else                printf(&quot;Raw Phys: %s\n&quot;, buf);            /* Get Raw Info */            //对应HIDIOCGRAWINFO。            res = ioctl(fd, HIDIOCGRAWINFO, &amp;info);            if (res &lt; 0) {                perror(&quot;HIDIOCGRAWINFO&quot;);            } else {                printf(&quot;Raw Info:\n&quot;);                printf(&quot;\tbustype: %d (%s)\n&quot;,                    info.bustype, bus_str(info.bustype));                printf(&quot;\tvendor: 0x%04hx\n&quot;, info.vendor);                printf(&quot;\tproduct: 0x%04hx\n&quot;, info.product);            }            /* Get Report Descriptor Size */            //对应HIDIOCGRDESCSIZE            res = ioctl(fd, HIDIOCGRDESCSIZE, &amp;desc_size);            if (res &lt; 0)                perror(&quot;HIDIOCGRDESCSIZE&quot;);            else                printf(&quot;Report Descriptor Size: %d\n&quot;, desc_size);            /* Get Report Descriptor */            rpt_desc.size = desc_size;            //对应HIDIOCGRDESC。            res = ioctl(fd, HIDIOCGRDESC, &amp;rpt_desc);            if (res &lt; 0) {                perror(&quot;HIDIOCGRDESC&quot;);            } else {                printf(&quot;Report Descriptor:\n&quot;);                for (i = 0; i &lt; rpt_desc.size; i++)                    printf(&quot;%hhx &quot;, rpt_desc.value[i]);                puts(&quot;\n&quot;);            }            /* Set Feature */            buf[0] = 0x9; /* Report Number */            buf[1] = 0xff;            buf[2] = 0xff;            buf[3] = 0xff;            //对应HIDIOCSFEATURE。            res = ioctl(fd, HIDIOCSFEATURE(4), buf);            if (res &lt; 0)                perror(&quot;HIDIOCSFEATURE&quot;);            else                printf(&quot;ioctl HIDIOCGFEATURE returned: %d\n&quot;, res);            /* Get Feature */            buf[0] = 0x9; /* Report Number */            //对应HIDIOCGFEATURE。            res = ioctl(fd, HIDIOCGFEATURE(256), buf);            if (res &lt; 0) {                perror(&quot;HIDIOCGFEATURE&quot;);            } else {                printf(&quot;ioctl HIDIOCGFEATURE returned: %d\n&quot;, res);                printf(&quot;Report data (not containing the report number):\n\t&quot;);                for (i = 0; i &lt; res; i++)                    printf(&quot;%hhx &quot;, buf[i]);                puts(&quot;\n&quot;);            }            /* Send a Report to the Device */            buf[0] = 0x1; /* Report Number */            buf[1] = 0x77;            res = write(fd, buf, 2);            if (res &lt; 0) {                printf(&quot;Error: %d\n&quot;, errno);                perror(&quot;write&quot;);            } else {                printf(&quot;write() wrote %d bytes\n&quot;, res);            }            /* Get a report from the device */            res = read(fd, buf, 16);            if (res &lt; 0) {                perror(&quot;read&quot;);            } else {                printf(&quot;read() read %d bytes:\n\t&quot;, res);                for (i = 0; i &lt; res; i++)                    printf(&quot;%hhx &quot;, buf[i]);                puts(&quot;\n&quot;);            }            close(fd);        }    }    return 0;}const char *bus_str(int bus){    switch (bus) {    case BUS_USB:        return &quot;USB&quot;;        break;    case BUS_HIL:        return &quot;HIL&quot;;        break;    case BUS_BLUETOOTH:        return &quot;Bluetooth&quot;;        break;    case BUS_VIRTUAL:        return &quot;Virtual&quot;;        break;    default:        return &quot;Other&quot;;        break;    }}</code></pre><blockquote><p> 综合来看hidraw设备是hid的一种，传输裸数据，对应的底层硬件可能是USB/Bluetooth等。</p><p>通过对hidraw设备的操作，ioctl可以配置hidraw设备，read/write可以对hidraw设备进行读写。</p></blockquote><p><a href="https://www.cnblogs.com/arnoldlu/p/11418391.html" target="_blank" rel="noopener">文章原连接</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Hidraw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HID Debug</title>
      <link href="/2020/02/26/2020/0226/hid/"/>
      <url>/2020/02/26/2020/0226/hid/</url>
      
        <content type="html"><![CDATA[<p>在Android系统经常需要分析蓝牙HID设备，特别HOGP协议的蓝牙输入设备 (UHID设备) ，以下从Linux角度，Bluedroid角度</p><p>看看有哪些debug手段吧。</p><p>##Linux角度</p><p>####Debug文件：</p><blockquote><p>通过 /sys/kernel/debug/hid/* 暴露的调试接口</p></blockquote><ul><li>HID设备的BUS:VendorID:ProductID</li></ul><pre><code>ls /sys/kernel/debug/hid/0005:046d:c534</code></pre><ul><li>HID设备描述符。</li></ul><pre><code>cat /sys/kernel/debug/hid/0005:01ef:07de/rdesc</code></pre><ul><li>实时上报Event。</li></ul><pre><code>cat /sys/kernel/debug/hid/0005:01ef:07de/events</code></pre><p>####Hidraw文件</p><blockquote><p>通过 /dev/hidraw* 设备节点观察数据上报情况，通过Hexdump命令解析数据</p></blockquote><pre><code>busybox hexdump -b /dev/hidraw0</code></pre><p>####lsusb(仅查看usb列表)</p><ul><li>Linux</li></ul><pre><code># lsusbBus 020 Device 003: ID 05ac:0274 Apple Inc. Apple Internal Keyboard / Trackpad  Serial: D3H74340QT1FTV4AY6FFBus 020 Device 002: ID 05ac:8290 Apple Inc. Bluetooth USB Host ControllerBus 000 Device 001: ID 1d6b:LPTH Linux Foundation USB 3.0 Bus</code></pre><ul><li>Android</li></ul><pre><code># busybox lsusb</code></pre>]]></content>
      
      
      <categories>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HID </tag>
            
            <tag> HOGP </tag>
            
            <tag> UHID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云Docker简单实战</title>
      <link href="/2020/02/23/2020/0223/aliyun-docker/"/>
      <url>/2020/02/23/2020/0223/aliyun-docker/</url>
      
        <content type="html"><![CDATA[<p>在阿里云买了个人服务，进行软件安装的时候，通过docker进行简单管理会比较清晰一下，可以开启和停止服务,我使用系统是<strong>Centos-7.5</strong></p><h1 id="Aliyun-安装-Docker指南"><a href="#Aliyun-安装-Docker指南" class="headerlink" title="Aliyun 安装 Docker指南"></a>Aliyun 安装 Docker指南</h1><p><a href="https://help.aliyun.com/document_detail/51853.html?spm=a2c4g.11186623.4.1.6b324c074Tvbxv" target="_blank" rel="noopener">搭建Docker</a></p><h2 id="部署Docker"><a href="#部署Docker" class="headerlink" title="部署Docker"></a>部署Docker</h2><ul><li>添加yum源</li></ul><pre><code>yum install epel-release –yyum clean allyum list</code></pre><ul><li>安装并运行Docker</li></ul><pre><code>yum install docker-io –ysystemctl start docker</code></pre><ul><li>检查安装结果</li></ul><pre><code>docker info</code></pre><h2 id="使用Docker"><a href="#使用Docker" class="headerlink" title="使用Docker"></a>使用Docker</h2><ul><li>管理Docker守护进程</li></ul><pre><code>systemctl start docker     #运行Docker守护进程systemctl stop docker      #停止Docker守护进程systemctl restart docker   #重启Docker守护进程</code></pre><ul><li>拉取镜像</li></ul><pre><code>docker pull registry.cn-hangzhou.aliyuncs.com/lxepoo/apache-php5</code></pre><ul><li>修改标签</li></ul><pre><code>docker tag registry.cn-hangzhou.aliyuncs.com/lxepoo/apache-php5:latest aliweb:v1</code></pre><ul><li>查看所有镜像</li></ul><pre><code>docker images</code></pre><ul><li>删除镜像</li></ul><pre><code>docker rmi –f registry.cn-hangzhou.aliyuncs.com/lxepoo/apache-php5</code></pre><h2 id="管理容器"><a href="#管理容器" class="headerlink" title="管理容器"></a>管理容器</h2><ul><li>运行进入容器</li></ul><pre><code>docker run -it containerId /bin/bash</code></pre><ul><li>退出容器</li></ul><pre><code>exit</code></pre><ul><li>进入后台运行容器</li></ul><pre><code>docker exec -it contianerId /bin/bash</code></pre><ul><li>将容器做成镜像</li></ul><pre><code>docker commit containerID/containerName repository:tag</code></pre><ul><li>将运行容器做成镜像</li></ul><pre><code>docker commit contianerId imageName:imageTag</code></pre><ul><li>删除容器</li></ul><pre><code>docker rm -f containerID</code></pre><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><ul><li>准备Dockerfile内容。</li></ul><pre><code># vim Dockerfile FROM apachephp:v1  #声明基础镜像来源MAINTAINER DTSTACK #声明镜像拥有者#RUN后面接容器运行前需要执行的命令，由于Dockerfile文件不能超过127行，因此当命令较多时建议写到脚本中执行RUN mkdir /dtstact #开机启动命令，此处最后一个命令需要是可在前台持续执行的命令，否则容器后台运行时会因为命令执行完而退出。ENTRYPOINT ping www.aliyun.com </code></pre><ul><li>构建镜像。</li></ul><pre><code>docker build -t webcentos:v1 .   # . 是Dockerfile文件的路径，不能忽略docker images                    #查看是否创建成功docker run –d webcentos:v1       #后台运行容器docker ps                        #查看当前运行中的容器docker ps –a                     #查看所有容器，包括未运行中的docker logs CONTAINER ID/IMAGE   #如未查看到刚才运行的容器，则用容器id或者名字查看启动日志排错docker commit fb2844b6c070 dtstackweb:v1 #commit 后接容器id 和构建新镜像的名称和版本号。docker images                    #列出本地（已下载的和本地创建的）镜像docker push                      #将镜像推送至远程仓库，默认为 Docker Hub</code></pre><ul><li>将镜像推送到registry</li></ul><pre><code>docker login --username=dtstack_plus registry.cn-shanghai.aliyuncs.com #执行后输入镜像仓库密码docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/dtstack123/test:[镜像版本号]docker push registry.cn-shanghai.aliyuncs.com/dtstack123/test:[镜像版本号]</code></pre><blockquote><p>其中<strong>ImageId</strong>和<strong>镜像版本号</strong>请您根据自己的镜像信息进行填写。</p></blockquote><p>在镜像仓库能查看到镜像版本信息则说明推送成功。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wordpress</title>
      <link href="/2020/02/23/2020/0223/wordpress/"/>
      <url>/2020/02/23/2020/0223/wordpress/</url>
      
        <content type="html"><![CDATA[<p>搭建 Wordpress 系统，我们通过Docker运行此博客系统，通过Docker-compose.yml进行安装。</p><h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><pre><code>mkdir wordpresscd wordpressvim docker-compose.yml</code></pre><h3 id="安装方法之一-compose"><a href="#安装方法之一-compose" class="headerlink" title="安装方法之一(compose)"></a>安装方法之一(compose)</h3><pre><code>curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose</code></pre><h3 id="安装方法之二-compose"><a href="#安装方法之二-compose" class="headerlink" title="安装方法之二(compose)"></a>安装方法之二(compose)</h3><h4 id="升级python3-0"><a href="#升级python3-0" class="headerlink" title="升级python3.0"></a>升级python3.0</h4><ul><li>依赖安装</li></ul><pre><code># yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel gcc</code></pre><ul><li>安装前查看当前系统下的python版本号</li></ul><pre><code># python -V</code></pre><ul><li>获取python3.x的官方软件包</li></ul><pre><code># wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz</code></pre><ul><li>解压缩该软件包</li></ul><pre><code># tar -zxvf Python-3.6.5.tgz</code></pre><ul><li>开启python3.0的SSL</li></ul><pre><code># vim Modules/Setup.dist</code></pre><blockquote><pre><code># Socket module helper for socket(2)_socket socketmodule.c# Socket module helper for SSL support; you must comment out the other# socket line above, and possibly edit the SSL variable:SSL=/usr/local/ssl_ssl _ssl.c \-DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \-L$(SSL)/lib -lssl -lcrypto</code></pre></blockquote><ul><li>在解压目录下安装配置</li></ul><pre><code># cd Python-3.6.5# ./configure</code></pre><ul><li>编译并安装</li></ul><pre><code># make# make install</code></pre><ul><li>Python2 &amp;&amp; Python3共存</li></ul><pre><code># which python3# python3 -v# python2 -v# pip -v# pip3 -v</code></pre><h4 id="pip安装-compose"><a href="#pip安装-compose" class="headerlink" title="pip安装(compose)"></a>pip安装(compose)</h4><ul><li>安装python-pip</li></ul><pre><code>yum -y install epel-releaseyum -y install python-pip</code></pre><ul><li>安装docker-compose</li></ul><pre><code>pip3 install docker-compose</code></pre><ul><li>验证</li></ul><pre><code>docker-compose version</code></pre><h3 id="构建项目-compose"><a href="#构建项目-compose" class="headerlink" title="构建项目(compose)"></a>构建项目(compose)</h3><pre><code>version: &quot;3&quot;services:  db:    image: 10.30.12.55/docker/mysql:5.6    volumes:      - /var/lib/mysql:/var/lib/mysql    #自动重启    restart: always    environment:      #指定MySQL的root账号初始密码      MYSQL_ROOT_PASSWORD: 123456      #指定容器启动后要创建的数据库      MYSQL_DATABASE: wordpress      #指定容器在启动后要创建的普通用户账号，该账号有远程登录的权限      MYSQL_USER: tom      #为用户设置密码      MYSQL_PASSWORD: 123456  wordpress:    depends_on:      - db    image: 10.30.12.55/docker/wordpress    ports:      - &quot;8000:80&quot;    restart: always    environment:      #指定要使用的数据库名      WORDPRESS_DB_NAME: wordpress      #指定要MySQL容器的ip和端口      WORDPRESS_DB_HOST: db:3306      #指定登录MySQL的账号      WORDPRESS_DB_USER: tom      #指定登录MySQL的密码      WORDPRESS_DB_PASSWORD: 123456</code></pre><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><pre><code>docker-compose up -d</code></pre><blockquote><p>Compose 就会拉取镜像再创建我们所需要的镜像，然后启动<br>wordpress 和数据库容器。 接着浏览器访问 ip:8000 端口就能看到 WordPress 安装<br>界面了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wordpress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片格式( SVG | WebP)</title>
      <link href="/2020/02/23/2020/0223/tu-pian-ge-shi/"/>
      <url>/2020/02/23/2020/0223/tu-pian-ge-shi/</url>
      
        <content type="html"><![CDATA[<p>SVG 和 WebP图片优缺点和适用范围，SVG适合做图标或者颜色变化不大的图片，WebP可以不降低质量的情况将资源降到比较低，适合做App瘦身。</p><h3 id="WebP简介"><a href="#WebP简介" class="headerlink" title="WebP简介"></a>WebP简介</h3><p><strong>WebP</strong>是谷歌提供的一种支持有损压缩和无损压缩的图片文件格式，而且可以提供比JPEG或PNG更好的压缩。</p><blockquote><p>在Android 4.0(API level 14)中支持有损的WebP图像</p><p>在Android 4.3(API level 18)和更高版本中支持无损和透明的WebP图像</p><p><strong>所以建议您的项目必须声明一个minSdkVersion 18或更高版本</strong></p></blockquote><h3 id="两者的优点"><a href="#两者的优点" class="headerlink" title="两者的优点"></a>两者的优点</h3><h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><ul><li>尺寸小, 压缩性强;</li><li>矢量图片;</li><li>XML编写;</li><li>图片内文字支持搜索, Web端适用;</li></ul><h4 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h4><ul><li>精细度不降低的前提下缩小图片体积;</li></ul><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><h4 id="SVG-1"><a href="#SVG-1" class="headerlink" title="SVG"></a>SVG</h4><ul><li>Web端: IE9开始兼容;</li><li>Android: 安卓3.X开始局部支持;</li><li>IOS: Safari简单支持, 复杂滤镜不可行;</li></ul><h4 id="WebP-1"><a href="#WebP-1" class="headerlink" title="WebP"></a>WebP</h4><ul><li>Web端: Chromium内核浏览器, 国内占比50%;</li><li>Android: 支持 ( Android4.0以上提供的原生支持, 4.0以下使用官方解析库) ;</li><li>IOS: 使用官方解析库;</li></ul><h3 id="图片大小"><a href="#图片大小" class="headerlink" title="图片大小"></a>图片大小</h3><h4 id="例子图片，转换后："><a href="#例子图片，转换后：" class="headerlink" title="例子图片，转换后："></a>例子图片，转换后：</h4><ul><li>转换为PNG后, 2.3M, 124K ;</li><li>转换为SVG后, 1.44M, 257K ; 有细微失真 ;</li><li>转换为WebP后, 91.5K, 16.3K ; 没有失真 ;</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过自己测试的两张图片, </p><ul><li><p>发现目前SVG更适合做图标, </p></li><li><p>色彩变化较为精细的图片转化为SVG格式后会变得更大，不太适合 ; </p></li><li><p>而WebP暂时没有发现什么弊端.</p></li></ul><blockquote><p>PS: 现在可以使用AndroidStudio直接转化webP, AS真乃亲爸</p></blockquote><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p><a href="https://isux.tencent.com/why-svg.html" target="_blank" rel="noopener">SVG</a></p></li><li><p><a href="https://isux.tencent.com/introduction-of-webp.html" target="_blank" rel="noopener">WebP</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多媒体 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github项目批量抓取</title>
      <link href="/2020/02/22/2020/0222/github-xiang-mu-pi-liang-zhua-qu/"/>
      <url>/2020/02/22/2020/0222/github-xiang-mu-pi-liang-zhua-qu/</url>
      
        <content type="html"><![CDATA[<p>有时候我们同步Github的项目时候，每次单个项目pull很麻烦，最终发现可以通过python3的脚步完成多个项目同步完成。</p><h1 id="首先安装"><a href="#首先安装" class="headerlink" title="首先安装"></a>首先安装</h1><ul><li>安装批量工具<pre><code>pip install ghcloneall</code></pre><h1 id="其次编辑"><a href="#其次编辑" class="headerlink" title="其次编辑"></a>其次编辑</h1></li><li>ROI_Origanizations格式说明<pre><code>vim ROI_Organizations.md</code></pre><blockquote><p>[OrgName] [u|o]<br>u 代表 OrgName 为用户<br>o 代表 OrgName 为 Organization</p></blockquote></li></ul><h1 id="然后抓取"><a href="#然后抓取" class="headerlink" title="然后抓取"></a>然后抓取</h1><ul><li>脚步执行命令<pre><code>python3 GitCrawler.py</code></pre><blockquote><p>参考安装链接：<a href="https://github.com/carywei/GitCrawler" target="_blank" rel="noopener">https://github.com/carywei/GitCrawler</a></p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年第一天班</title>
      <link href="/2020/02/03/2020/0203/2020-nian-di-yi-tian-ban/"/>
      <url>/2020/02/03/2020/0203/2020-nian-di-yi-tian-ban/</url>
      
        <content type="html"><![CDATA[<p>现在是晚上2020-02-30 06:26 我在内蒙古赤峰旺业甸服务区，由于下雪高速封路，我们在高速入口处等待高速封路解除，与工作人员沟通预计上午10点可以通行。</p><h2 id="现在所想"><a href="#现在所想" class="headerlink" title="现在所想"></a>现在所想</h2><h3 id="聊聊BYD秦续航"><a href="#聊聊BYD秦续航" class="headerlink" title="聊聊BYD秦续航"></a>聊聊BYD秦续航</h3><ul><li>标准里程表显示400公里</li><li>夏天实际行驶预计在360公里，因为剩下40公里需要找充电桩，呵呵。</li><li>冬天实际行驶预计在200公里，因为天气冷的原因，电池能耗比较低。</li></ul><h3 id="目的北京"><a href="#目的北京" class="headerlink" title="目的北京"></a>目的北京</h3><pre><code>* 途径矛荆坝服务区* 途径安子岭服务区* 途径太师屯服务区</code></pre><h3 id="抵达北京家中封闭"><a href="#抵达北京家中封闭" class="headerlink" title="抵达北京家中封闭"></a>抵达北京家中封闭</h3><pre><code>* 备了很多面条* 备了不少蘑菇酱* 备了一些萝卜</code></pre><h3 id="期望今年能够平稳度过"><a href="#期望今年能够平稳度过" class="headerlink" title="期望今年能够平稳度过"></a>期望今年能够平稳度过</h3><pre><code>* 工作顺利* 完成业绩* 突破自我* 自我卓越</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Hello World</title>
      <link href="/2019/12/24/2019/1224/hello-world/"/>
      <url>/2019/12/24/2019/1224/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

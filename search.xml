<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ueventd.rc</title>
      <link href="/2020/03/03/2020/0303/ueventd/"/>
      <url>/2020/03/03/2020/0303/ueventd/</url>
      
        <content type="html"><![CDATA[<p>与Linux相同，Android中的应用程序通过设备驱动访问硬件设备。设备节点文件是设备驱动的逻辑文件，应用程序使用设备节点文件来访问驱动程序。</p><p>在Linux中，运行所需的设备节点文件被被预先定义在“/dev”目录下。应用程序无需经过其它步骤，通过预先定义的设备节点文件即可访问设备驱动程序。<br>但根据Android的init进程的启动过程，我们知道，Android根文件系统的映像中不存在“/dev”目录，该目录是init进程启动后动态创建的。<br>因此，建立Anroid中设备节点文件的重任，也落在了init进程身上。为此，init进程创建子进程ueventd，并将创建设备节点文件的工作托付给ueventd。</p><h3 id="ueventd两种方式创建设备节点"><a href="#ueventd两种方式创建设备节点" class="headerlink" title="ueventd两种方式创建设备节点"></a>ueventd两种方式创建设备节点</h3><ul><li>第一种方式对应“冷插拔”（Cold Plug），即以预先定义的设备信息为基础，当ueventd启动后，统一创建设备节点文件。这一类设备节点文件也被称为静态节点文件。 </li><li>第二种方式对应“热插拔”（Hot Plug），即在系统运行中，当有设备插入USB端口时，ueventd就会接收到这一事件，为插入的设备动态创建设备节点文件。这一类设备节点文件也被称为动态节点文件。</li></ul><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a><strong>背景知识</strong></h3><p>在Linux内核2.6版本之前，用户必须直接创建设备节点文件。创建时，必须保证设备文件的主次设备号不发生重叠，再通过mknod进行实际地创建。这样做的缺点是，用户必须记住各个设备的主设备号和次设备号，还要避免设备号之间发生冲突，操作起来较为麻烦。<br>为了弥补这一不足，从内核2.6x开始引入udev(userspace device)，udev以守护进程的形式运行。当设备驱动被加载时，它会掌握主设备号、次设备号，以及设备类型，而后在“/dev”目录下自动创建设备节点文件。<br>从加载设备驱动到udev创建设备节点文件的整个过程如下图所示：</p><p><img src="https://carywei.github.io/2020/03/03/2020/0303/ueventd/uevented.png?raw=true" alt="img"></p><p><strong>/</strong></p><p>在系统运行中，若某个设备被插入，内核就会加载与该设备相关的驱动程序。<br>接着，驱动程序的启动函数probe将被调用（定义于设备驱动程序中，由内核自动调用，用来初始化设备），将主设备号、次设备号、设备类型保存到“/sys”文件系统中。<br>然后，驱动程序发送uevent给udev守护进程。<br>最后，udev通过分析内核发出的uevent，查看注册在/sys目录下的设备信息，以在/dev目录相应位置上创建节点文件。</p><p><strong>//</strong></p><p>uevent是内核向用户空间进程传递信息的信号系统，即在添加或删除设备时，内核使用uevent将设备信息传递到用户空间。uevent包含设备名称、类别、主设备号、次设备号、设备节点文件需要被创建的目录等信息。</p><p><strong>///</strong></p><p>系统内核启动后，udev进程运行在用户空间内，它无法处理内核启动过程中发生的uevent。虽然内核空间内的设备驱动程序可以正常运行，但由于未创建设备访问驱动所需的设备节点文件，将会出现应用程序无法使用相关设备的问题。<br>Linux系统中，通过冷插拔机制来解决该问题。当内核启动后，冷插拔机制启动udev守护进程，从/sys目录下读取实现注册好的设备信息，而后引发与各设备对应的uevent，创建设备节点。</p><p>总结一下：<br>热插拔时，设备连接后，内核调用驱动程序加载信息到/sys下，然后驱动程序发送uevent到udev；<br>冷插拔时，udev主动读取/sys目录下的信息，然后触发uevent给自己处理。之所以要有冷插拔，是因为内核加载部分驱动程序信息的时间，早于启动udev的时间。</p><p>接下来，我们看看Android中的ueventd是怎么做的。</p><p><strong>正文</strong><br><strong>一、启动ueventd</strong></p><pre><code>......init_parse_config_file(&quot;/init.rc&quot;);action_for_each_trigger(&quot;early-init&quot;, action_add_queue_tail);......</code></pre><p>在init进程的启动过程中，解析完init.rc文件后，首先将“early-init”对应的action加入到运行队列中。因此，当init进程开始处理运行队列中的事件时，首先会处理该action。</p><pre><code>on early-init    # Set init and its forked children&#39;s oom_adj.    write /proc/1/oom_score_adj -1000    # Set the security context of /adb_keys if present.    restorecon /adb_keys    start ueventd</code></pre><p>如上所示，为init.rc内“early-init”对应的action，我们可以看到，将执行start ueventd的命令。</p><p>根据keywords.h中的定义，我们知道action的start关键字，对应函数do_start，定义于system/core/init/builtins.cpp中：</p><pre><code>int do_start(int nargs, char **args){    struct service *svc;    svc = service_find_by_name(args[1]);    if (svc) {        service_start(svc, NULL);    }    return 0;}</code></pre><p>如上代码所示，do_start函数通过service_find_by_name函数，从service_list链表中，根据参数找到需启动的service，然后调用service_start函数启动service。</p><p>service_start函数定义于init.cpp文件中：</p><pre><code>void service_start(struct service *svc, const char *dynamic_args) {    ..............    pid_t pid = fork();    if (pid == 0) {        ........        if (!dynamic_args) {            if (execve(svc-&gt;args[0], (char**) svc-&gt;args, (char**) ENV) &lt; 0) {                ..............            }        } else {            ............            execve(svc-&gt;args[0], (char**) arg_ptrs, (char**) ENV);    }}</code></pre><p>该函数对参数进行检查后，利用fork函数创建出子进程，然后按照service在init.rc中的定义，对service进行配置，最后调用Linux系统函数execve启动service。</p><p><strong>二、ueventd的主要工作</strong><br>ueventd_main定义于文件system/core/init/ueventd.cpp中，主要进行以下工作：</p><pre><code>int ueventd_main(int argc, char **argv) {    //与init进程启动一样，ueventd首先调用umask(0)以清除屏蔽字，保证新建的目录访问权限不受屏蔽字影响    umask(000);    //忽略子进程终止信号    signal(SIGCHLD, SIG_IGN);    ...........}</code></pre><p>如上面代码所示，ueventd调用signal函数，忽略子进程终止产生的SIGCHLD信号。</p><p>=============================以下非主干，可跳过=============================<br><em>I</em><br>signal函数的功能是：为指定的信号安装一个新的信号处理函数。</p><p>signal函数的原型是：<br><em>void (</em> signal( int signo, void (<em>func)(int) ) )(int);</em><br>其中：<br>signo参数是信号名；</p><p>func的值是常量SIG_IGN、常量SIG_DFL或当接到此信号后要调用的函数的地址。<br>如果指定SIG_IGN，则向内核表示忽略此信号（记住有两个信号SIGKILL和SIGSTOP不能忽略）；<br>如果指定SIG_DFL，则表示接到此信号后的动作是系统默认动作；<br>当指定函数地址时，则在信号发生时，调用该函数。我们称这种处理为“捕捉”该信号，称此函数为信号处理程序（signal handler）或信号捕捉函数（signal catching function）。</p><p>signal的返回值是指向之前的信号处理程序的指针。（也就是返回执行signal 函数之前，对信号signo的信号处理程序指针）。</p><p><em>II</em><br>对于某些进程，特别是服务器进程，往往在请求到来时生成子进程进行处理。如果父进程不处理子进程结束的信号，子进程将成为僵尸进程（zombie）从而占用系统资源；如果父进程处理子进程结束的信号，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将 SIGCHLD信号的操作设为SIG_IGN，可让内核把子进程的信号转交给init进程去处理。</p><p>回忆init进程的启动过程，我们知道init进程确实注册了针对SIGCHLD的信号处理器。</p><p>=============================以上非主干，可跳过=============================</p><p>我们回到ueventd的ueventd_main函数：</p><pre><code>..........//与init进程一样，屏蔽标准输入输出open_devnull_stdio();//初始化内核log系统klog_init();klog_set_level(KLOG_NOTICE_LEVEL);NOTICE(&quot;ueventd started!\n&quot;);selinux_callback cb;cb.func_log = selinux_klog_callback;//注册selinux相关的用于打印log的回调函数selinux_set_callback(SELINUX_CB_LOG, cb);...........//获取硬件相关信息char hardware[PROP_VALUE_MAX];property_get(&quot;ro.hardware&quot;, hardware);//解析ueventd.rc文件ueventd_parse_config_file(&quot;/ueventd.rc&quot;);//解析厂商相关的ueventd.{hardware}.rc文件ueventd_parse_config_file(android::base::StringPrintf(&quot;/ueventd.%s.rc&quot;, hardware).c_str());..........</code></pre><p>在分析ueventd_parse_config_file函数前，我们先看看ueventd.rc中大概的内容。</p><pre><code>.........../dev/null                 0666   root       root/dev/zero                 0666   root       root/dev/full                 0666   root       root/dev/ptmx                 0666   root       root/dev/tty                  0666   root       root/dev/random               0666   root       root..........</code></pre><p>从上面的代码，可以看出ueventd.rc中主要记录的就是设备节点文件的名称、访问权限、用户ID、组ID。</p><p>ueventd_parse_config_file函数定义于system/core/init/ueventd_parser.cpp中：</p><pre><code>int ueventd_parse_config_file(const char *fn){    std::string data;    //将文件读取成string    if (!read_file(fn, &amp;data)) {        return -1;    }    data.push_back(&#39;\n&#39;); // TODO: fix parse_config.    //解析string    parse_config(fn, data);    dump_parser_state();    return 0;}</code></pre><p>从上面代码可以看出，与init进程解析init.rc文件一样，ueventd也是利用ueventd_parse_config_file函数，将指定路径对应的文件读取出来，然后再做进一步解析。</p><pre><code>static void parse_config(const char *fn, const std::string&amp; data) {    ........    for (;;) {        //分段        int token = next_token(&amp;state);        switch (token) {        case T_EOF:            parse_line(&amp;state, args, nargs);            return;        case T_NEWLINE:            if (nargs) {                //解析                parse_line(&amp;state, args, nargs);                nargs = 0;            }            state.line++;            break;        case T_TEXT:            if (nargs &lt; UEVENTD_PARSER_MAXARGS) {                args[nargs++] = state.text;            }            break;        }    }}</code></pre><p>parse_config定义于system/core/init/ueventd_parser.cpp中，如上面代码所示，我们可以看出ueventd解析ueventd.rc的逻辑，与init进程解析init.rc文件基本一致，即以行为单位，调用parse_line逐行地解析ueventd.rc文件。</p><p>parse_line定义于system/core/init/ueventd_parser.cpp中：</p><pre><code>static void parse_line(struct parse_state *state, char **args, int nargs) {    int kw = lookup_keyword(args[0]);    .........    if (kw_is(kw, SECTION)) {        parse_new_section(state, kw, nargs, args);    } else if (kw_is(kw, OPTION)) {        state-&gt;parse_line(state, nargs, args);    } else {        parse_line_device(state, nargs, args);    }}static void parse_new_section(struct parse_state *state, int kw, int nargs, char **args){    ..........    switch(kw) {    case K_subsystem:        state-&gt;context = parse_subsystem(state, nargs, args);        if (state-&gt;context) {            state-&gt;parse_line = parse_line_subsystem;            return;        }        break;    }    state-&gt;parse_line = parse_line_no_op;}static void parse_line_device(parse_state*, int nargs, char** args) {    set_device_permission(nargs, args);}</code></pre><p>从上面的代码可以看出，parse_line根据解析出来的关键字，调用不同的函数进行处理。其中，parse_new_section主要用于处理ueventd.rc文件中，subsystem对应的数据；对于dev对应的数据，需要调用parse_line_device进行处理。</p><p>parse_line_device主要调用set_device_permission函数：</p><pre><code>void set_device_permission(int nargs, char **args) {    .......    add_dev_perms(name, attr, perm, uid, gid, prefix, wildcard);    .......}</code></pre><p>set_device_permission函数定义于/system/core/init/ueventd.cpp中，主要根据参数，获取设备名、uid、gid、权限等，然后调用add_dev_perms函数。</p><pre><code>struct perm_node {    struct perms_ dp;    struct listnode plist;};int add_dev_perms(.....) {    struct perm_node *node = (perm_node*) calloc(1, sizeof(*node));    //根据输入参数构造结构体perm_node    ......    if (attr)        list_add_tail(&amp;sys_perms, &amp;node-&gt;plist);    else        list_add_tail(&amp;dev_perms, &amp;node-&gt;plist);    return 0;}</code></pre><p>add_dev_perms定于文件/system/core/init/devices.cpp中，如上面代码所示，根据输入参数构造结构体perm_node，然后将perm_node加入到对应的双向链表中(perm_node中也是通过包含listnode来构建双向链表的)。</p><p>注意到，根据参数attr，构造出的perm_node将分别被加入到sys_perms和dev_perms中。<br>attr的值由之前的set_device_permission函数决定，当ueventd.rc中的设备名以/sys/开头时，attr的值才可能为1。一般的设备以/dev/开头，应该被加载到dev_perms链表中。</p><p>看完解析ueventd.rc的过程后，我们再次将视角拉回到uevent_main函数的后续过程。</p><pre><code>...........device_init();...........</code></pre><p>device_init定义于system/core/init/devices.cpp中，我们来看看该函数的实际工作：</p><pre><code>void device_init() {    sehandle = NULL;    if (is_selinux_enabled() &gt; 0) {        //进行安全相关的操作        sehandle = selinux_android_file_context_handle();        selinux_status_open(true);    }    //创建socket，该socekt用于监听后续的uevent事件    device_fd = uevent_open_socket(256*1024, true);    if (device_fd == -1) {        return;    }    //通过fcntl函数，将device_fd置为非阻塞。    fcntl(device_fd, F_SETFL, O_NONBLOCK);    //通过access函数判断文件/dev/.coldboot_done（COLDBOOT_DONE）是否存在    //若该路径下的文件存在，表明已经进行过冷插拔。    if (access(COLDBOOT_DONE, F_OK) == 0) {        NOTICE(&quot;Skipping coldboot, already done!\n&quot;);        return;    }    //调用coldboot函数，处理/sys/目录下的驱动程序    Timer t;    coldboot(&quot;/sys/class&quot;);    coldboot(&quot;/sys/block&quot;);    coldboot(&quot;/sys/devices&quot;);    //冷插拔处理完毕后，创建文件/dev/.coldboot_done    close(open(COLDBOOT_DONE, O_WRONLY|O_CREAT|O_CLOEXEC, 0000));    NOTICE(&quot;Coldboot took %.2fs.\n&quot;, t.duration());}</code></pre><p>根据上述代码，我们知道了，ueventd调用device_init函数，创建一个socket来接收uevent，再对内核启动时注册到/sys/下的驱动程序进行“冷插拔”处理，以创建对应的节点文件。</p><p>我们来看看coldboot的过程：</p><pre><code>static void coldboot(const char *path){    //打开路径对应目录    //opendir函数打开path指向的目录，如果成功则返回一个DIR类型的指针，DIR指针指向path目录下的第一个条目    DIR *d = opendir(path);    if(d) {        //实际的“冷启动”        do_coldboot(d);        closedir(d);    }}static void do_coldboot(DIR *d){    struct dirent *de;    int dfd, fd;    //取得目录流文件描述符    dfd = dirfd(d);    fd = openat(dfd, &quot;uevent&quot;, O_WRONLY);    if(fd &gt;= 0) {        //写入事件，触发uevent        write(fd, &quot;add\n&quot;, 4);        close(fd);        //接收uevent，并进行处理        handle_device_fd();    }    //递归文件目录，继续执行do_coldboot    //readdir() 会返回参数对应条目的信息，以struct dirent形式展现，然后DIR指针会指向下一个条目    while((de = readdir(d))) {        DIR *d2;        if(de-&gt;d_type != DT_DIR || de-&gt;d_name[0] == &#39;.&#39;)            continue;        fd = openat(dfd, de-&gt;d_name, O_RDONLY | O_DIRECTORY);        if(fd &lt; 0)            continue;        d2 = fdopendir(fd);        if(d2 == 0)            close(fd);        else {            do_coldboot(d2);            closedir(d2);        }    }}</code></pre><p>从上面的代码，我们可以看出do_coldboot递归查询“/sys/class”、“/sys/block”和“/sys/devices”目录下所有的“uevent”文件，然后在这些文件中写入“add”，而后会强制触发uevent，并调用handle_device_fd()。handle_device_fd函数负责接收uevent信息，并创建节点文件（后文介绍其代码）。</p><p><em>int openat(int dirfd, const char *pathname, int flags)</em><br><em>openat系统调用与open功能类似，但用法上有以下不同：</em><br><em>如果pathname是相对地址，则以dirfd作为相对地址的寻址目录，而open是从当前目录开始寻址的；</em><br><em>如果pathname是相对地址，且dirfd的值是AT_FDCWD，则openat的行为与open一样，从当前目录开始相对寻址；</em><br><em>如果pathname是绝对地址，则dirfd参数不起作用。</em></p><p>冷插拔结束后，uevent_main剩余的工作，就是监听并处理热插拔事件了。</p><pre><code>.......ollfd ufd;ufd.events = POLLIN;//获取device_init中创建出的socketufd.fd = get_device_fd();while (true) {    ufd.revents = 0;    //监听来自驱动的uevent    int nr = poll(&amp;ufd, 1, -1);    if (nr &lt;= 0) {        continue;    }    if (ufd.revents &amp; POLLIN) {        //进行实际的事件处理        handle_device_fd();    }}    return 0;}</code></pre><p>从上面的代码可以看出，ueventd监听到uevent事件后，主要利用handle_device_fd函数进行处理。handle_device_fd定义于/system/core/init/devices.cpp中：</p><pre><code>void handle_device_fd() {    ........    //uevent_kernel_multicast_recv的功能就是读取写入到device_fd上的数据，其中封装调用了recvmsg函数    //读取数据将被存入到msg变量中，数据的长度为n    while ((n = uevent_kernel_multicast_recv(device_fd, msg, UEVENT_MSG_LEN)) &gt; 0) {        .........        //parse_event的功能是按格式将收到的数据解析成uevent        parse_event(msg, &amp;uevent);        ....        handle_device_event(&amp;uevent);        //处理firmware对应的uevent的函数，在此不做分析        handle_firmware_event(&amp;uevent);    }}</code></pre><p>从上面代码可以看出，实际处理uevent的函数为handle_device_event。</p><pre><code>static void handle_device_event(struct uevent *uevent){    ........    if (!strncmp(uevent-&gt;subsystem, &quot;block&quot;, 5)) {        handle_block_device_event(uevent);    } else if (!strncmp(uevent-&gt;subsystem, &quot;platform&quot;, 8)) {        handle_platform_device_event(uevent);    } else {        handle_generic_device_event(uevent);    }}</code></pre><p>handle_device_event根据uevent的类型调用相应的函数进行处理。此处，我们重点看看handle_generic_device_event函数。</p><pre><code>static void handle_generic_device_event(struct uevent *uevent) {    .........    name = parse_device_name(uevent, 64);    .........    if (subsystem) {        ......    } else if (!strncmp(uevent-&gt;subsystem, &quot;usb&quot;, 3)) {        ......    } else if (!strncmp(uevent-&gt;subsystem, &quot;graphics&quot;, 8)) {         base = &quot;/dev/graphics/&quot;;         make_dir(base, 0755);    } else if (!strncmp(uevent-&gt;subsystem, &quot;drm&quot;, 3)) {         base = &quot;/dev/dri/&quot;;         make_dir(base, 0755);    } ................       else {       base = &quot;/dev/&quot;;    }    .........    handle_device(uevent-&gt;action, devpath, uevent-&gt;path, 0, uevent-&gt;major, uevent-&gt;minor, links);}</code></pre><p>handle_generic_device_event函数代码较多（大量if、else），其实就是从uevent中解析出设备的信息，然后根据设备的类型在dev下创建出对应的目录。<br>在创建完目录后，将调用函数handle_device，最终通过mknod创建出设备节点文件。</p><pre><code>static void handle_device(......） {    ........    make_device(devpath, path, block, major, minor, (const char **)links);     ........}static void make_device(......) {    .............    mode = get_device_perm(path, links, &amp;uid, &amp;gid) | (block ? S_IFBLK : S_IFCHR);    ..............    mknod(path, mode, dev);    .............}</code></pre><p><strong>结束语</strong><br>以上对android ueventd的简要分析，这里主要需要了解“冷启动”和“热启动”的概念，了解概念后，代码相对还是比较好理解的。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ueventd.rc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>printf</title>
      <link href="/2020/03/02/2020/0302/printf/"/>
      <url>/2020/03/02/2020/0302/printf/</url>
      
        <content type="html"><![CDATA[<p>针对C语音打印，总是容易迷，所以总结一下</p><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><pre><code>#include &lt;stdio.h&gt;...int printf ( const char * format, ... );</code></pre><ul><li><p>format 参数是格式化字符串，由格式化<strong>占位符</strong>和<strong>普通字符</strong>组成。</p></li><li><p><strong>“ , ”</strong>后面接的是与<strong>占位符</strong>所对应数据。</p></li><li><p><strong>格式化占位符</strong>（以 % 开头）用于指明<strong>参数值用什么格式化输出</strong>。</p></li></ul><h3 id="打印格式"><a href="#打印格式" class="headerlink" title="打印格式"></a>打印格式</h3><table><thead><tr><th>符号</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>“%c”</td><td>char；</td><td>字符</td></tr><tr><td>“%d”</td><td>int；</td><td>有符号十进制整数</td></tr><tr><td>“%s”</td><td>char *；</td><td>字符串</td></tr><tr><td>“%f”</td><td>double;</td><td>以小数形式输出单、双精度浮点数</td></tr><tr><td>“%e”</td><td>double;</td><td>以指数形式输出单、双精度浮点数（大写 E 同e）</td></tr><tr><td>“%g”</td><td>double;</td><td>以 %f 或 %e 中较短的输出宽度输出单（大写G    同g）</td></tr><tr><td>“%u”</td><td>unsigned int；</td><td>无符号十进制</td></tr><tr><td>“%o”</td><td>unsigned int；</td><td>无符号八进制（无前导 0）</td></tr><tr><td>“%x”</td><td>unsigned int；</td><td>无符号十六进制（无前导 0x）（大写X    同x）</td></tr><tr><td>“%p”</td><td>void *；</td><td>指针值</td></tr><tr><td><strong>“n%”</strong></td><td>int *；</td><td>存放已写字符的个数</td></tr><tr><td>“%%”</td><td>%字符</td><td>不进行参数转换；% 自身</td></tr></tbody></table><h3 id="length（长度修饰符，可选）"><a href="#length（长度修饰符，可选）" class="headerlink" title="length（长度修饰符，可选）"></a>length（长度修饰符，可选）</h3><blockquote><p>length（长度修饰符，可选）的值可以是 h、hh、l、ll 或 L</p></blockquote><ul><li>hh 表示将相应的参数按 signed char 或 unsigned char 类型输出</li><li>h 表示将相应的参数按 short 或 unsigned short 类型输出</li><li>l 表示将相应的参数按 long 或 unsigned long 类型输出</li><li>ll 表示将相应的参数按 long long 或 unsigned long long 类型输出</li><li>L 表示将相应的参数按 long double 类型输出</li></ul><h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><pre><code>#include &lt;stdio.h&gt;int main(){        int a = 520;        int x = 1;        char b = &#39;a&#39;;        char greeting[]=&quot;two words&quot;;        float c = 3.14;        double d = 3.141592653;        printf(&quot;尝试打印输出两个整型数字%d和%d在一个句子中\n&quot;, a,x);        printf(&quot;尝试打印输出一个字符%c在一个句子中\n&quot;, b);        printf(&quot;尝试打印输出一个字符串%s在一个句子中\n&quot;, greeting);        printf(&quot;尝试打印输出一个精确到小数点后两位的数字：%.2f\n&quot;, c);        printf(&quot;尝试打印输出一个精确到小数点后9位、宽度为11位的数字：%11.9f\n&quot;, d);        return 0;}</code></pre><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><blockquote><p><strong>\a</strong>      Write a <bell> character.<br><strong>\b</strong>      Write a <backspace> character.<br><strong>\c</strong>      Ignore remaining characters in this string.<br> <strong>\f</strong>      Write a <form-feed> character.<br><strong>\n</strong>      Write a <new-line> character.<br><strong>\r</strong>      Write a <carriage return> character.<br><strong>\t</strong>      Write a <tab> character.<br><strong>\v</strong>      Write a <vertical tab> character.<br><strong>&#39;</strong>      Write a <single quote> character.<br><strong>\</strong>      Write a backslash character.<br><strong>\num</strong>    Write a byte whose value is the 1-, 2-, or 3-digit octal number num.  Multibyte characters can be constructed using<br>                   multiple \num sequences.</p></blockquote><p><a href="https://blog.csdn.net/dugudaibo/article/details/82712273" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sepolicy(SEAndroid)</title>
      <link href="/2020/02/29/2020/0229/sepolicy/"/>
      <url>/2020/02/29/2020/0229/sepolicy/</url>
      
        <content type="html"><![CDATA[<p>SEAndroid 是一种基于安全策略的MAC安全机制, 同时是SELinux 在Android 上面的移植应用。</p><p>SELinux 是Linux上系统保护机制，SELinux 全称 Security Enhanced Linux (安全强化 Linux)，是MAC (Mandatory Access Control，强制访问控制系统)的一个实现。其目的在于明确的指明某个进程可以访问哪些资源(文件、网络端口等)。</p><p>Android系统基于Linux实现。针对传统Linux系统，NSA开发了一套安全机制SELinux，用来加强安全性。然而，由于Android系 统有着独特的用户空间运行时，因此SELinux不能完全适用于Android系统。为此，NSA同Google一起针对Android系统，在SELinux基础上开发了 SEAndroid。</p><h3 id="检查SEAndroid状态"><a href="#检查SEAndroid状态" class="headerlink" title="检查SEAndroid状态"></a>检查SEAndroid状态</h3><pre><code>$ adb shellnexus_6p:$ getenforcenexus_6p:$ Permissive</code></pre><ul><li><p>Enforcing：强制模式，SELinux 运作中，且已经正确的开始限制 domain/type</p></li><li><p>Permissive：宽容模式，SELinux 运作中，仅会有警告讯息并不会限制 domain/type 的存取</p></li></ul><h3 id="查看进程和文件的SEAndroid状态"><a href="#查看进程和文件的SEAndroid状态" class="headerlink" title="查看进程和文件的SEAndroid状态"></a>查看进程和文件的SEAndroid状态</h3><ul><li>ps -efZ 可以查看进程的安全label</li></ul><pre><code># ps -efZLABEL                          UID            PID  PPID C STIME TTY          TIME CMDu:r:init:s0                    root             1     0 0 00:08 ?        00:00:07 initu:r:kernel:s0                  root             2     0 0 00:08 ?        00:00:00 [kthreadd]u:r:mediaprovider:s0:c512,c768 u0_a11        2813   649 0 01:04 ?        00:00:01 android.process.mediau:r:untrusted_app:s0:c512,c768 u0_a95        2851   649 0 01:04 ?        00:00:00 com.android.smspush</code></pre><ul><li>ls -alZ 可以看到文件的label（安全上下文）。</li></ul><pre><code># ls -alZ-rw-r--r--   1 root      root   u:object_r:sepolicy_file:s0                  551659 2020-02-29 15:51 sepolicydrwxr-xr-x   4 root      root   u:object_r:storage_file:s0                       80 2020-02-29 16:01 storagedr-xr-xr-x  15 root      root   u:object_r:sysfs:s0                               0 1970-01-02 12:40 sysdrwxr-xr-x  16 root      root   u:object_r:system_file:s0                      4096 2020-02-29 15:56 system-rw-r--r--   1 root      root   u:object_r:rootfs:s0                           5370 2020-02-28 15:54 ueventd.rcdrwxr-xr-x  15 root      root   u:object_r:vendor_file:s0                      4096 1970-01-01 08:00 vendor-rw-r--r--   1 root      root   u:object_r:vndservice_contexts_file:s0          559 2020-02-29 15:51 vndservice_contexts</code></pre><h3 id="更改SEAndroid状态"><a href="#更改SEAndroid状态" class="headerlink" title="更改SEAndroid状态"></a>更改SEAndroid状态</h3><pre><code>$ adb shell getenforce      //会返回 Enforcing 或 Permissive$ adb shell setenforce 1|0  //设置其为 Enforcing 或 Permissive</code></pre><h3 id="自动进程修改SEAndroid"><a href="#自动进程修改SEAndroid" class="headerlink" title="自动进程修改SEAndroid"></a>自动进程修改SEAndroid</h3><ul><li>修改 /system/sepolicy/private/file_contexts</li></ul><pre><code>/system/bin/bnsd              u:object_r:bnsd_service_exec:s0</code></pre><ul><li>修改 /system/sepolicy/private/service_contexts</li></ul><pre><code>bnsd                          u:object_r:bnsd_service_exec:s0</code></pre><ul><li>修改 /system/private/system_app.te</li></ul><pre><code>allow system_app { -bnsd_service}</code></pre><ul><li>添加 /system/sepolicy/private/bnsd.te</li></ul><pre><code>typeattribute bnsd coredomain;init_daamon_domain(bnsd)</code></pre><ul><li>修改 /system/sepolicy/public/domain.te</li></ul><pre><code>neverallow{}{   -bnsd_service}</code></pre><ul><li>修改 /system/sepolicy/dumpstate.te</li></ul><pre><code>allow dumpstate { -bnsd-service }</code></pre><ul><li>修改 /system/sepolicy/public/service.te</li></ul><pre><code>type bnsd_service service_manager_type;</code></pre><ul><li>修改 /system/sepolicy/public/shell.te</li></ul><pre><code>allow shell { -bnsd_service }</code></pre><ul><li>添加 /system/sepolilcy/public/bnsd.te</li></ul><pre><code>type bnsd, domain;type bnsd_exec, exec_type, file_type;binder_use(bnsd)binder_service(bnsd)add_service(bnsd, bnsd_service)# Needed to check app permissions.binder_call(bnsd, system_server)# Requires access to /dev/uinput to create and feed the virtual device.allow bnsd uhid_device:chr_file { w_file_perms ioctl };# Requires access to the permission service to validate that clients have the# appropriate VR permissions.allow bnsd permission_service:service_manager find;</code></pre>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Sepolicy </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HIDRAW</title>
      <link href="/2020/02/28/2020/0228/hidraw/"/>
      <url>/2020/02/28/2020/0228/hidraw/</url>
      
        <content type="html"><![CDATA[<p>hidraw设备主要用途，然后简要分析hidraw设备驱动，最后分析用户空间接口并实例。</p><h2 id="Hidraw介绍"><a href="#Hidraw介绍" class="headerlink" title="Hidraw介绍"></a>Hidraw介绍</h2><p>在内核<a href="https://elixir.bootlin.com/linux/latest/source/Documentation/hid/hidraw.rst" target="_blank" rel="noopener">Documentation/hid/hidraw.txt</a>中对hidraw设备进行介绍，以及和hiddev的区别。</p><p>hidraw提供了一个通过USB/Bluetooth接口的裸数据接口，它和hiddev的区别体现在数据不经过HID parse解析，而且直接数据传输。</p><blockquote><p>如果用户空间应用程序知道怎么恰当和硬件设备通信，和能够手动构建HID 报表，那么hidraw应该被使用。这通常是在用户控件驱动自定义HID 设备的时候。</p><p>Hidraw与不符合规范的HID 设备通信也是有利 的，这些设备以一种不符合报表描述符不一致的方式发送和接收数据。因为Hiddev解析器通过他发送和接收报表，检测设备的报表描述符，这样的通信是不可能使用hiddev。Hidraw是唯一的选择，为这些不兼容的设备编写一个定制的内核驱动程序。</p><p>Hidraw一个好处是用户空间应用程序使用独立的底层硬件类型。当前，hidraw是通过bluetooth 和 usb实现。在将来，随着硬件总线的发展，hidraw将支持更多的类型。</p></blockquote><p><img src="https://carywei.github.io/2020/02/28/2020/0228/hidraw/hidraw.png?raw=true" alt="img"></p><h2 id="Hidraw驱动"><a href="#Hidraw驱动" class="headerlink" title="Hidraw驱动"></a>Hidraw驱动</h2><ul><li>hidraw也是hid类设备</li></ul><pre><code>static int __init hid_init(void){    int ret;...        //注册总线hid_bus_type    ret = bus_register(&amp;hid_bus_type);...        //hidraw_init()被hid_init调用    ret = hidraw_init();    if (ret)        goto err_bus;        //创建/sys/kernel/debug/hid调试接口    hid_debug_init();...}static void __exit hid_exit(void){    hid_debug_exit();    hidraw_exit();    bus_unregister(&amp;hid_bus_type);}</code></pre><pre><code>struct hidraw {------------------------------&gt;struct hidraw是hidraw设备实例    unsigned int minor;----------------------&gt;从设备号。    int exist;-------------------------------&gt;表示设备是否连接。    int open;--------------------------------&gt;表示设备open计数。    wait_queue_head_t wait;    struct hid_device *hid;------------------&gt;对应hid设备实例。    struct device *dev;    spinlock_t list_lock;    struct list_head list;};struct hidraw_report {    __u8 *value;    int len;};struct hidraw_list {-------------------------&gt;是hidraw设备一次传输的实例。    struct hidraw_report buffer[HIDRAW_BUFFER_SIZE];    int head;    int tail;    struct fasync_struct *fasync;    struct hidraw *hidraw;    struct list_head node;    struct mutex read_mutex;};</code></pre><h2 id="Hid总线"><a href="#Hid总线" class="headerlink" title="Hid总线"></a>Hid总线</h2><pre><code>static struct bus_type hid_bus_type = {    .name          = &quot;hid&quot;,    .dev_groups    = hid_dev_groups,    .match         = hid_bus_match,    .probe         = hid_device_probe,    .remove        = hid_device_remove,    .uevent        = hid_uevent,};static int hid_uevent(struct device *dev, struct kobj_uevent_env *env){    struct hid_device *hdev = to_hid_device(dev);        if (add_uevent_var(env, &quot;HID_ID=%04X:%08X:%08X&quot;,            hdev-&gt;bus, hdev-&gt;vendor, hdev-&gt;product))        return -ENOMEM;    if (add_uevent_var(env, &quot;HID_NAME=%s&quot;, hdev-&gt;name))        return -ENOMEM;    if (add_uevent_var(env, &quot;HID_PHYS=%s&quot;, hdev-&gt;phys))        return -ENOMEM;    if (add_uevent_var(env, &quot;HID_UNIQ=%s&quot;, hdev-&gt;uniq))        return -ENOMEM;    if (add_uevent_var(env, &quot;MODALIAS=hid:b%04Xg%04Xv%08Xp%08X&quot;,               hdev-&gt;bus, hdev-&gt;group, hdev-&gt;vendor, hdev-&gt;product))        return -ENOMEM;    return 0;}</code></pre><h2 id="Hidraw初始化"><a href="#Hidraw初始化" class="headerlink" title="Hidraw初始化"></a>Hidraw初始化</h2><pre><code>int __init hidraw_init(void){    int result;    dev_t dev_id;        //从设备号0~63。    result = alloc_chrdev_region(&amp;dev_id, HIDRAW_FIRST_MINOR,            HIDRAW_MAX_DEVICES, &quot;hidraw&quot;);    if (result &lt; 0) {        pr_warn(&quot;can&#39;t get major number\n&quot;);        goto out;    }    hidraw_major = MAJOR(dev_id);        //创建hidraw设备类。    hidraw_class = class_create(THIS_MODULE, &quot;hidraw&quot;);    if (IS_ERR(hidraw_class)) {        result = PTR_ERR(hidraw_class);        goto error_cdev;    }    //初始化一个字符设备hidraw_dev，操作函数集为hidraw_ops。    cdev_init(&amp;hidraw_cdev, &amp;hidraw_ops);    result = cdev_add(&amp;hidraw_cdev, dev_id, HIDRAW_MAX_DEVICES);    if (result &lt; 0)        goto error_class;    printk(KERN_INFO &quot;hidraw: raw HID events driver (C) Jiri Kosina\n&quot;);out:    return result;error_class:    class_destroy(hidraw_class);error_cdev:    unregister_chrdev_region(dev_id, HIDRAW_MAX_DEVICES);    goto out;}void hidraw_exit(void){    dev_t dev_id = MKDEV(hidraw_major, 0);    cdev_del(&amp;hidraw_cdev);    class_destroy(hidraw_class);    unregister_chrdev_region(dev_id, HIDRAW_MAX_DEVICES);}</code></pre><h2 id="hidraw设备操作"><a href="#hidraw设备操作" class="headerlink" title="hidraw设备操作"></a>hidraw设备操作</h2><pre><code>static const struct file_operations hidraw_ops = {    .owner =        THIS_MODULE,    .read =         hidraw_read,    .write =        hidraw_write,    .poll =         hidraw_poll,    .open =         hidraw_open,    .release =      hidraw_release,    .unlocked_ioctl = hidraw_ioctl,    .fasync =    hidraw_fasync,#ifdef CONFIG_COMPAT    .compat_ioctl   = hidraw_ioctl,#endif    .llseek =    noop_llseek,};static ssize_t hidraw_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos){    struct hidraw_list *list = file-&gt;private_data;    int ret = 0, len;    DECLARE_WAITQUEUE(wait, current);    mutex_lock(&amp;list-&gt;read_mutex);    while (ret == 0) {        if (list-&gt;head == list-&gt;tail) {            add_wait_queue(&amp;list-&gt;hidraw-&gt;wait, &amp;wait);            set_current_state(TASK_INTERRUPTIBLE);            while (list-&gt;head == list-&gt;tail) {                if (signal_pending(current)) {                    ret = -ERESTARTSYS;                    break;                }                if (!list-&gt;hidraw-&gt;exist) {                    ret = -EIO;                    break;                }                if (file-&gt;f_flags &amp; O_NONBLOCK) {                    ret = -EAGAIN;                    break;                }                /* allow O_NONBLOCK to work well from other threads */                mutex_unlock(&amp;list-&gt;read_mutex);                schedule();                mutex_lock(&amp;list-&gt;read_mutex);                set_current_state(TASK_INTERRUPTIBLE);            }            set_current_state(TASK_RUNNING);            remove_wait_queue(&amp;list-&gt;hidraw-&gt;wait, &amp;wait);        }        if (ret)            goto out;        len = list-&gt;buffer[list-&gt;tail].len &gt; count ?            count : list-&gt;buffer[list-&gt;tail].len;        if (list-&gt;buffer[list-&gt;tail].value) {            if (copy_to_user(buffer, list-&gt;buffer[list-&gt;tail].value, len)) {                ret = -EFAULT;                goto out;            }            ret = len;        }        kfree(list-&gt;buffer[list-&gt;tail].value);        list-&gt;buffer[list-&gt;tail].value = NULL;        list-&gt;tail = (list-&gt;tail + 1) &amp; (HIDRAW_BUFFER_SIZE - 1);    }out:    mutex_unlock(&amp;list-&gt;read_mutex);    return ret;}static ssize_t hidraw_send_report(struct file *file, const char __user *buffer, size_t count, unsigned char report_type){    unsigned int minor = iminor(file_inode(file));    struct hid_device *dev;    __u8 *buf;    int ret = 0;    if (!hidraw_table[minor] || !hidraw_table[minor]-&gt;exist) {        ret = -ENODEV;        goto out;    }        //根据minor号找到对应hidraw设备的hid_device。    dev = hidraw_table[minor]-&gt;hid;...    buf = memdup_user(buffer, count);    if (IS_ERR(buf)) {        ret = PTR_ERR(buf);        goto out;    }    if ((report_type == HID_OUTPUT_REPORT) &amp;&amp;        !(dev-&gt;quirks &amp; HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP)) {        ret = hid_hw_output_report(dev, buf, count);        if (ret != -ENOSYS)            goto out_free;    }        //调用实际硬件接口发送report，比如usb、bluetooth等。    ret = hid_hw_raw_request(dev, buf[0], buf, count, report_type,                HID_REQ_SET_REPORT);out_free:    kfree(buf);out:    return ret;}static ssize_t hidraw_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos){    ssize_t ret;    mutex_lock(&amp;minors_lock);    ret = hidraw_send_report(file, buffer, count, HID_OUTPUT_REPORT);    mutex_unlock(&amp;minors_lock);    return ret;}static ssize_t hidraw_get_report(struct file *file, char __user *buffer, size_t count, unsigned char report_type){    unsigned int minor = iminor(file_inode(file));    struct hid_device *dev;    __u8 *buf;    int ret = 0, len;    unsigned char report_number;    dev = hidraw_table[minor]-&gt;hid;...    buf = kmalloc(count * sizeof(__u8), GFP_KERNEL);    if (!buf) {        ret = -ENOMEM;        goto out;    }    if (copy_from_user(&amp;report_number, buffer, 1)) {        ret = -EFAULT;        goto out_free;    }        //从硬件接口接收数据。    ret = hid_hw_raw_request(dev, report_number, buf, count, report_type,                 HID_REQ_GET_REPORT);...    if (copy_to_user(buffer, buf, len)) {        ret = -EFAULT;        goto out_free;    }    ret = len;out_free:    kfree(buf);out:    return ret;}static unsigned int hidraw_poll(struct file *file, poll_table *wait){    struct hidraw_list *list = file-&gt;private_data;    poll_wait(file, &amp;list-&gt;hidraw-&gt;wait, wait);    if (list-&gt;head != list-&gt;tail)        return POLLIN | POLLRDNORM;    if (!list-&gt;hidraw-&gt;exist)        return POLLERR | POLLHUP;    return 0;}static int hidraw_open(struct inode *inode, struct file *file){    unsigned int minor = iminor(inode);    struct hidraw *dev;    struct hidraw_list *list;    unsigned long flags;    int err = 0;    if (!(list = kzalloc(sizeof(struct hidraw_list), GFP_KERNEL))) {        err = -ENOMEM;        goto out;    }    mutex_lock(&amp;minors_lock);    if (!hidraw_table[minor] || !hidraw_table[minor]-&gt;exist) {        err = -ENODEV;        goto out_unlock;    }    dev = hidraw_table[minor];    if (!dev-&gt;open++) {        //调用底层设备即具体接口的power()函数，hdev-&gt;ll_driver-&gt;power()。        err = hid_hw_power(dev-&gt;hid, PM_HINT_FULLON);--------------        if (err &lt; 0) {            dev-&gt;open--;            goto out_unlock;        }                //调用底层设备的open()函数，hdev-&gt;ll_driver-&gt;open()。        err = hid_hw_open(dev-&gt;hid);        if (err &lt; 0) {            hid_hw_power(dev-&gt;hid, PM_HINT_NORMAL);            dev-&gt;open--;            goto out_unlock;        }    }    list-&gt;hidraw = hidraw_table[minor];    mutex_init(&amp;list-&gt;read_mutex);    spin_lock_irqsave(&amp;hidraw_table[minor]-&gt;list_lock, flags);    list_add_tail(&amp;list-&gt;node, &amp;hidraw_table[minor]-&gt;list);    spin_unlock_irqrestore(&amp;hidraw_table[minor]-&gt;list_lock, flags);    file-&gt;private_data = list;...}static int hidraw_fasync(int fd, struct file *file, int on){    struct hidraw_list *list = file-&gt;private_data;        //发送异步通知信号。    return fasync_helper(fd, file, on, &amp;list-&gt;fasync);}static void drop_ref(struct hidraw *hidraw, int exists_bit){    if (exists_bit) {        hidraw-&gt;exist = 0;        if (hidraw-&gt;open) {            hid_hw_close(hidraw-&gt;hid);            wake_up_interruptible(&amp;hidraw-&gt;wait);        }        device_destroy(hidraw_class,                   MKDEV(hidraw_major, hidraw-&gt;minor));    } else {            //打开计算减1。        --hidraw-&gt;open;    }    if (!hidraw-&gt;open) {//当计数为0后，开始释放资源。        if (!hidraw-&gt;exist) {            hidraw_table[hidraw-&gt;minor] = NULL;            kfree(hidraw);        } else {            /* close device for last reader */            hid_hw_power(hidraw-&gt;hid, PM_HINT_NORMAL);            hid_hw_close(hidraw-&gt;hid);        }    }}static int hidraw_release(struct inode * inode, struct file * file){    unsigned int minor = iminor(inode);    struct hidraw_list *list = file-&gt;private_data;    unsigned long flags;    mutex_lock(&amp;minors_lock);    spin_lock_irqsave(&amp;hidraw_table[minor]-&gt;list_lock, flags);    list_del(&amp;list-&gt;node);    spin_unlock_irqrestore(&amp;hidraw_table[minor]-&gt;list_lock, flags);    kfree(list);    drop_ref(hidraw_table[minor], 0);    mutex_unlock(&amp;minors_lock);    return 0;}static long hidraw_ioctl(struct file *file, unsigned int cmd,                            unsigned long arg){    struct inode *inode = file_inode(file);    unsigned int minor = iminor(inode);    long ret = 0;    struct hidraw *dev;    void __user *user_arg = (void __user*) arg;    mutex_lock(&amp;minors_lock);    dev = hidraw_table[minor];    if (!dev) {        ret = -ENODEV;        goto out;    }    switch (cmd) {        case HIDIOCGRDESCSIZE://Get report descriptor size。            if (put_user(dev-&gt;hid-&gt;rsize, (int __user *)arg))                ret = -EFAULT;            break;        case HIDIOCGRDESC://Get report descriptor。            {                __u32 len;                if (get_user(len, (int __user *)arg))                    ret = -EFAULT;                else if (len &gt; HID_MAX_DESCRIPTOR_SIZE - 1)                    ret = -EINVAL;                else if (copy_to_user(user_arg + offsetof(                    struct hidraw_report_descriptor,                    value[0]),                    dev-&gt;hid-&gt;rdesc,                    min(dev-&gt;hid-&gt;rsize, len)))                    ret = -EFAULT;                break;            }        case HIDIOCGRAWINFO://Get raw info，包括bus类型，vid和pid。            {                struct hidraw_devinfo dinfo;                dinfo.bustype = dev-&gt;hid-&gt;bus;                dinfo.vendor = dev-&gt;hid-&gt;vendor;                dinfo.product = dev-&gt;hid-&gt;product;                if (copy_to_user(user_arg, &amp;dinfo, sizeof(dinfo)))                    ret = -EFAULT;                break;            }        default:            {                struct hid_device *hid = dev-&gt;hid;                if (_IOC_TYPE(cmd) != &#39;H&#39;) {                    ret = -EINVAL;                    break;                }                                //Send a feature report。                if (_IOC_NR(cmd) == _IOC_NR(HIDIOCSFEATURE(0))) {                    int len = _IOC_SIZE(cmd);                    ret = hidraw_send_report(file, user_arg, len, HID_FEATURE_REPORT);                    break;                }                //Get a feature report。                if (_IOC_NR(cmd) == _IOC_NR(HIDIOCGFEATURE(0))) {                    int len = _IOC_SIZE(cmd);                    ret = hidraw_get_report(file, user_arg, len, HID_FEATURE_REPORT);                    break;                }                /* Begin Read-only ioctls. */                if (_IOC_DIR(cmd) != _IOC_READ) {                    ret = -EINVAL;                    break;                }                                //Get raw name。                if (_IOC_NR(cmd) == _IOC_NR(HIDIOCGRAWNAME(0))) {                    int len = strlen(hid-&gt;name) + 1;                    if (len &gt; _IOC_SIZE(cmd))                        len = _IOC_SIZE(cmd);                    ret = copy_to_user(user_arg, hid-&gt;name, len) ?                        -EFAULT : len;                    break;                }                                //Get physical address。                if (_IOC_NR(cmd) == _IOC_NR(HIDIOCGRAWPHYS(0))) {                    int len = strlen(hid-&gt;phys) + 1;                    if (len &gt; _IOC_SIZE(cmd))                        len = _IOC_SIZE(cmd);                    ret = copy_to_user(user_arg, hid-&gt;phys, len) ?                        -EFAULT : len;                    break;                }            }        ret = -ENOTTY;    }out:    mutex_unlock(&amp;minors_lock);    return ret;}</code></pre><p>由于一个系统下可能存在多个hidraw设备，常通过HIDIOCGRAWINFO获取信息，判断对应的hidraw设备。</p><pre><code>int hidraw_connect(struct hid_device *hid){    int minor, result;    struct hidraw *dev;    /* we accept any HID device, all applications */    dev = kzalloc(sizeof(struct hidraw), GFP_KERNEL);    if (!dev)        return -ENOMEM;    result = -EINVAL;    mutex_lock(&amp;minors_lock);    //分配hidraw设备的minor号，并将dev赋给hidraw_table[]。    for (minor = 0; minor &lt; HIDRAW_MAX_DEVICES; minor++) {        if (hidraw_table[minor])            continue;        hidraw_table[minor] = dev;        result = 0;        break;    }    if (result) {        mutex_unlock(&amp;minors_lock);        kfree(dev);        goto out;    }        //创建/dev/hidrawX设备节点。    dev-&gt;dev = device_create(hidraw_class, &amp;hid-&gt;dev, MKDEV(hidraw_major, minor),                 NULL, &quot;%s%d&quot;, &quot;hidraw&quot;, minor);    if (IS_ERR(dev-&gt;dev)) {        hidraw_table[minor] = NULL;        mutex_unlock(&amp;minors_lock);        result = PTR_ERR(dev-&gt;dev);        kfree(dev);        goto out;    }    init_waitqueue_head(&amp;dev-&gt;wait);    spin_lock_init(&amp;dev-&gt;list_lock);    INIT_LIST_HEAD(&amp;dev-&gt;list);    dev-&gt;hid = hid;    dev-&gt;minor = minor;    dev-&gt;exist = 1;    hid-&gt;hidraw = dev;    mutex_unlock(&amp;minors_lock);out:    return result;}EXPORT_SYMBOL_GPL(hidraw_connect);void hidraw_disconnect(struct hid_device *hid){    struct hidraw *hidraw = hid-&gt;hidraw;    mutex_lock(&amp;minors_lock);    drop_ref(hidraw, 1);    mutex_unlock(&amp;minors_lock);}EXPORT_SYMBOL_GPL(hidraw_disconnect);</code></pre><blockquote><p>所以hidraw的驱动分为两部分，一是hidraw_init()发起的整个hidraw设备驱动的初始化，二是底层驱动检测到hidraw设备后通过hidraw_connect()/hidraw_disconnect()创建或者销毁设备。</p><p>当USB/Bluetooth检查到设备是hidraw类型之后，就会调用hidraw提供的接口创建设备，表现为创建节点/dev/hidrawx。</p><p>后续用户空间程序对/dev/hidrawx进行read/write/ioctl等操作。</p></blockquote><h2 id="hidraw测试程序"><a href="#hidraw测试程序" class="headerlink" title="hidraw测试程序"></a>hidraw测试程序</h2><p>内核提供了一个示例程序 <a href="https://elixir.bootlin.com/linux/latest/source/samples/hidraw/hid-example.c" target="_blank" rel="noopener">hid-example.c</a> 下面结合内核代码简单分析一下。遍历/dev下所有的hidraw设备，然后读取信息。</p><pre><code>/* Linux */#include &lt;linux/types.h&gt;#include &lt;linux/input.h&gt;#include &lt;linux/hidraw.h&gt;#include &lt;dirent.h&gt;#ifndef HIDIOCSFEATURE#warning Please have your distro update the userspace kernel headers#define HIDIOCSFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, &#39;H&#39;, 0x06, len)#define HIDIOCGFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, &#39;H&#39;, 0x07, len)#endif/* Unix */#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;/* C */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;const char *bus_str(int bus);int main(int argc, char **argv){    int fd;    int i, res, desc_size = 0;    char buf[256];    struct hidraw_report_descriptor rpt_desc;    struct hidraw_devinfo info;    char device[32] = &quot;/dev/hidraw0&quot;;    DIR *dir = NULL;    struct dirent *ptr;    /* Open dir /dev. */    dir = opendir(&quot;/dev&quot;);    if(!dir) {        perror(&quot;Popen dir failed...&quot;);        return -ENOENT;    }    /* 遍历/dev目录下所有的文件。 */    while(ptr = readdir(dir)) {            //判断设备是否为字符设备，其他设备包括            //DT_UNKNOWN/DT_FIFO/DT_CHR DT_DIR/DT_BLK/DT_REG/DT_LNK/DT_SOCK/DT_WHT。        if(ptr-&gt;d_type != DT_CHR)            continue;if(!strncmp(ptr-&gt;d_name, &quot;hidraw&quot;, 6)) {            snprintf(device, sizeof(device), &quot;%s/%s&quot;, &quot;/dev&quot;, ptr-&gt;d_name);            /* Open the Device with non-blocking reads. In real life,               don&#39;t use a hard coded path; use libudev instead. */            //打开hidraw设备，对应内核的hidraw_open()。               fd = open(device, O_RDWR|O_NONBLOCK);            if (fd &lt; 0) {                printf(&quot;Unable to open device %s.\n&quot;, device);                return 1;            }            memset(&amp;rpt_desc, 0x0, sizeof(rpt_desc));            memset(&amp;info, 0x0, sizeof(info));            memset(buf, 0x0, sizeof(buf));            printf(&quot;\n\n=================================Device %s info=================================\n&quot;, device);            /* Get Raw Name */            //对应hidraw_ioctl()的HIDIOCGRAWNAME。            res = ioctl(fd, HIDIOCGRAWNAME(256), buf);            if (res &lt; 0)                perror(&quot;HIDIOCGRAWNAME&quot;);            else                printf(&quot;Raw Name: %s\n&quot;, buf);            /* Get Physical Location */            //对应HIDIOCGRAWPHYS。            res = ioctl(fd, HIDIOCGRAWPHYS(256), buf);            if (res &lt; 0)                perror(&quot;HIDIOCGRAWPHYS&quot;);            else                printf(&quot;Raw Phys: %s\n&quot;, buf);            /* Get Raw Info */            //对应HIDIOCGRAWINFO。            res = ioctl(fd, HIDIOCGRAWINFO, &amp;info);            if (res &lt; 0) {                perror(&quot;HIDIOCGRAWINFO&quot;);            } else {                printf(&quot;Raw Info:\n&quot;);                printf(&quot;\tbustype: %d (%s)\n&quot;,                    info.bustype, bus_str(info.bustype));                printf(&quot;\tvendor: 0x%04hx\n&quot;, info.vendor);                printf(&quot;\tproduct: 0x%04hx\n&quot;, info.product);            }            /* Get Report Descriptor Size */            //对应HIDIOCGRDESCSIZE            res = ioctl(fd, HIDIOCGRDESCSIZE, &amp;desc_size);            if (res &lt; 0)                perror(&quot;HIDIOCGRDESCSIZE&quot;);            else                printf(&quot;Report Descriptor Size: %d\n&quot;, desc_size);            /* Get Report Descriptor */            rpt_desc.size = desc_size;            //对应HIDIOCGRDESC。            res = ioctl(fd, HIDIOCGRDESC, &amp;rpt_desc);            if (res &lt; 0) {                perror(&quot;HIDIOCGRDESC&quot;);            } else {                printf(&quot;Report Descriptor:\n&quot;);                for (i = 0; i &lt; rpt_desc.size; i++)                    printf(&quot;%hhx &quot;, rpt_desc.value[i]);                puts(&quot;\n&quot;);            }            /* Set Feature */            buf[0] = 0x9; /* Report Number */            buf[1] = 0xff;            buf[2] = 0xff;            buf[3] = 0xff;            //对应HIDIOCSFEATURE。            res = ioctl(fd, HIDIOCSFEATURE(4), buf);            if (res &lt; 0)                perror(&quot;HIDIOCSFEATURE&quot;);            else                printf(&quot;ioctl HIDIOCGFEATURE returned: %d\n&quot;, res);            /* Get Feature */            buf[0] = 0x9; /* Report Number */            //对应HIDIOCGFEATURE。            res = ioctl(fd, HIDIOCGFEATURE(256), buf);            if (res &lt; 0) {                perror(&quot;HIDIOCGFEATURE&quot;);            } else {                printf(&quot;ioctl HIDIOCGFEATURE returned: %d\n&quot;, res);                printf(&quot;Report data (not containing the report number):\n\t&quot;);                for (i = 0; i &lt; res; i++)                    printf(&quot;%hhx &quot;, buf[i]);                puts(&quot;\n&quot;);            }            /* Send a Report to the Device */            buf[0] = 0x1; /* Report Number */            buf[1] = 0x77;            res = write(fd, buf, 2);            if (res &lt; 0) {                printf(&quot;Error: %d\n&quot;, errno);                perror(&quot;write&quot;);            } else {                printf(&quot;write() wrote %d bytes\n&quot;, res);            }            /* Get a report from the device */            res = read(fd, buf, 16);            if (res &lt; 0) {                perror(&quot;read&quot;);            } else {                printf(&quot;read() read %d bytes:\n\t&quot;, res);                for (i = 0; i &lt; res; i++)                    printf(&quot;%hhx &quot;, buf[i]);                puts(&quot;\n&quot;);            }            close(fd);        }    }    return 0;}const char *bus_str(int bus){    switch (bus) {    case BUS_USB:        return &quot;USB&quot;;        break;    case BUS_HIL:        return &quot;HIL&quot;;        break;    case BUS_BLUETOOTH:        return &quot;Bluetooth&quot;;        break;    case BUS_VIRTUAL:        return &quot;Virtual&quot;;        break;    default:        return &quot;Other&quot;;        break;    }}</code></pre><blockquote><p> 综合来看hidraw设备是hid的一种，传输裸数据，对应的底层硬件可能是USB/Bluetooth等。</p><p>通过对hidraw设备的操作，ioctl可以配置hidraw设备，read/write可以对hidraw设备进行读写。</p></blockquote><p><a href="https://www.cnblogs.com/arnoldlu/p/11418391.html" target="_blank" rel="noopener">文章原连接</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Hidraw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HID Debug</title>
      <link href="/2020/02/26/2020/0226/hid/"/>
      <url>/2020/02/26/2020/0226/hid/</url>
      
        <content type="html"><![CDATA[<p>在Android系统经常需要分析蓝牙HID设备，特别HOGP协议的蓝牙输入设备 (UHID设备) ，以下从Linux角度，Bluedroid角度</p><p>看看有哪些debug手段吧。</p><h2 id="Linux角度"><a href="#Linux角度" class="headerlink" title="Linux角度"></a>Linux角度</h2><h4 id="Debug文件："><a href="#Debug文件：" class="headerlink" title="Debug文件："></a>Debug文件：</h4><blockquote><p>通过 /sys/kernel/debug/hid/* 暴露的调试接口</p></blockquote><ul><li>HID设备的BUS:VendorID:ProductID</li></ul><pre><code>ls /sys/kernel/debug/hid/0005:046d:c534</code></pre><ul><li>HID设备描述符。</li></ul><pre><code>cat /sys/kernel/debug/hid/0005:01ef:07de/rdesc</code></pre><ul><li>实时上报Event。</li></ul><pre><code>cat /sys/kernel/debug/hid/0005:01ef:07de/events</code></pre><h4 id="Hidraw文件"><a href="#Hidraw文件" class="headerlink" title="Hidraw文件"></a>Hidraw文件</h4><blockquote><p>通过 /dev/hidraw* 设备节点观察数据上报情况，通过Hexdump命令解析数据</p></blockquote><pre><code>busybox hexdump -b /dev/hidraw0</code></pre><h4 id="lsusb-仅查看usb列表"><a href="#lsusb-仅查看usb列表" class="headerlink" title="lsusb(仅查看usb列表)"></a>lsusb(仅查看usb列表)</h4><ul><li>Linux</li></ul><pre><code># lsusbBus 020 Device 003: ID 05ac:0274 Apple Inc. Apple Internal Keyboard / Trackpad  Serial: D3H74340QT1FTV4AY6FFBus 020 Device 002: ID 05ac:8290 Apple Inc. Bluetooth USB Host ControllerBus 000 Device 001: ID 1d6b:LPTH Linux Foundation USB 3.0 Bus</code></pre><ul><li>Android</li></ul><pre><code># busybox lsusb</code></pre>]]></content>
      
      
      <categories>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HID </tag>
            
            <tag> HOGP </tag>
            
            <tag> UHID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wordpress</title>
      <link href="/2020/02/23/2020/0223/wordpress/"/>
      <url>/2020/02/23/2020/0223/wordpress/</url>
      
        <content type="html"><![CDATA[<p>搭建 Wordpress 系统，我们通过Docker运行此博客系统，通过Docker-compose.yml进行安装。</p><h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><pre><code>mkdir wordpresscd wordpressvim docker-compose.yml</code></pre><h3 id="安装方法之一-compose"><a href="#安装方法之一-compose" class="headerlink" title="安装方法之一(compose)"></a>安装方法之一(compose)</h3><pre><code>curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose</code></pre><h3 id="安装方法之二-compose"><a href="#安装方法之二-compose" class="headerlink" title="安装方法之二(compose)"></a>安装方法之二(compose)</h3><h4 id="升级python3-0"><a href="#升级python3-0" class="headerlink" title="升级python3.0"></a>升级python3.0</h4><ul><li>依赖安装</li></ul><pre><code># yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel gcc</code></pre><ul><li>安装前查看当前系统下的python版本号</li></ul><pre><code># python -V</code></pre><ul><li>获取python3.x的官方软件包</li></ul><pre><code># wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz</code></pre><ul><li>解压缩该软件包</li></ul><pre><code># tar -zxvf Python-3.6.5.tgz</code></pre><ul><li>开启python3.0的SSL</li></ul><pre><code># vim Modules/Setup.dist</code></pre><blockquote><pre><code># Socket module helper for socket(2)_socket socketmodule.c# Socket module helper for SSL support; you must comment out the other# socket line above, and possibly edit the SSL variable:SSL=/usr/local/ssl_ssl _ssl.c \-DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \-L$(SSL)/lib -lssl -lcrypto</code></pre></blockquote><ul><li>在解压目录下安装配置</li></ul><pre><code># cd Python-3.6.5# ./configure</code></pre><ul><li>编译并安装</li></ul><pre><code># make# make install</code></pre><ul><li>Python2 &amp;&amp; Python3共存</li></ul><pre><code># which python3# python3 -v# python2 -v# pip -v# pip3 -v</code></pre><h4 id="pip安装-compose"><a href="#pip安装-compose" class="headerlink" title="pip安装(compose)"></a>pip安装(compose)</h4><ul><li>安装python-pip</li></ul><pre><code>yum -y install epel-releaseyum -y install python-pip</code></pre><ul><li>安装docker-compose</li></ul><pre><code>pip3 install docker-compose</code></pre><ul><li>验证</li></ul><pre><code>docker-compose version</code></pre><h3 id="构建项目-compose"><a href="#构建项目-compose" class="headerlink" title="构建项目(compose)"></a>构建项目(compose)</h3><pre><code>version: &quot;3&quot;services:  db:    image: 10.30.12.55/docker/mysql:5.6    volumes:      - /var/lib/mysql:/var/lib/mysql    #自动重启    restart: always    environment:      #指定MySQL的root账号初始密码      MYSQL_ROOT_PASSWORD: 123456      #指定容器启动后要创建的数据库      MYSQL_DATABASE: wordpress      #指定容器在启动后要创建的普通用户账号，该账号有远程登录的权限      MYSQL_USER: tom      #为用户设置密码      MYSQL_PASSWORD: 123456  wordpress:    depends_on:      - db    image: 10.30.12.55/docker/wordpress    ports:      - &quot;8000:80&quot;    restart: always    environment:      #指定要使用的数据库名      WORDPRESS_DB_NAME: wordpress      #指定要MySQL容器的ip和端口      WORDPRESS_DB_HOST: db:3306      #指定登录MySQL的账号      WORDPRESS_DB_USER: tom      #指定登录MySQL的密码      WORDPRESS_DB_PASSWORD: 123456</code></pre><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><pre><code>docker-compose up -d</code></pre><blockquote><p>Compose 就会拉取镜像再创建我们所需要的镜像，然后启动<br>wordpress 和数据库容器。 接着浏览器访问 ip:8000 端口就能看到 WordPress 安装<br>界面了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> blogs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wordpress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云Docker简单实战</title>
      <link href="/2020/02/23/2020/0223/aliyun-docker/"/>
      <url>/2020/02/23/2020/0223/aliyun-docker/</url>
      
        <content type="html"><![CDATA[<p>在阿里云买了个人服务，进行软件安装的时候，通过docker进行简单管理会比较清晰一下，可以开启和停止服务,我使用系统是<strong>Centos-7.5</strong></p><h1 id="Aliyun-安装-Docker指南"><a href="#Aliyun-安装-Docker指南" class="headerlink" title="Aliyun 安装 Docker指南"></a>Aliyun 安装 Docker指南</h1><p><a href="https://help.aliyun.com/document_detail/51853.html?spm=a2c4g.11186623.4.1.6b324c074Tvbxv" target="_blank" rel="noopener">搭建Docker</a></p><h2 id="部署Docker"><a href="#部署Docker" class="headerlink" title="部署Docker"></a>部署Docker</h2><ul><li>添加yum源</li></ul><pre><code>yum install epel-release –yyum clean allyum list</code></pre><ul><li>安装并运行Docker</li></ul><pre><code>yum install docker-io –ysystemctl start docker</code></pre><ul><li>检查安装结果</li></ul><pre><code>docker info</code></pre><h2 id="使用Docker"><a href="#使用Docker" class="headerlink" title="使用Docker"></a>使用Docker</h2><ul><li>管理Docker守护进程</li></ul><pre><code>systemctl start docker     #运行Docker守护进程systemctl stop docker      #停止Docker守护进程systemctl restart docker   #重启Docker守护进程</code></pre><ul><li>拉取镜像</li></ul><pre><code>docker pull registry.cn-hangzhou.aliyuncs.com/lxepoo/apache-php5</code></pre><ul><li>修改标签</li></ul><pre><code>docker tag registry.cn-hangzhou.aliyuncs.com/lxepoo/apache-php5:latest aliweb:v1</code></pre><ul><li>查看所有镜像</li></ul><pre><code>docker images</code></pre><ul><li>删除镜像</li></ul><pre><code>docker rmi –f registry.cn-hangzhou.aliyuncs.com/lxepoo/apache-php5</code></pre><h2 id="管理容器"><a href="#管理容器" class="headerlink" title="管理容器"></a>管理容器</h2><ul><li>运行进入容器</li></ul><pre><code>docker run -it containerId /bin/bash</code></pre><ul><li>退出容器</li></ul><pre><code>exit</code></pre><ul><li>进入后台运行容器</li></ul><pre><code>docker exec -it contianerId /bin/bash</code></pre><ul><li>将容器做成镜像</li></ul><pre><code>docker commit containerID/containerName repository:tag</code></pre><ul><li>将运行容器做成镜像</li></ul><pre><code>docker commit contianerId imageName:imageTag</code></pre><ul><li>删除容器</li></ul><pre><code>docker rm -f containerID</code></pre><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><ul><li>准备Dockerfile内容。</li></ul><pre><code># vim Dockerfile FROM apachephp:v1  #声明基础镜像来源MAINTAINER DTSTACK #声明镜像拥有者#RUN后面接容器运行前需要执行的命令，由于Dockerfile文件不能超过127行，因此当命令较多时建议写到脚本中执行RUN mkdir /dtstact #开机启动命令，此处最后一个命令需要是可在前台持续执行的命令，否则容器后台运行时会因为命令执行完而退出。ENTRYPOINT ping www.aliyun.com </code></pre><ul><li>构建镜像。</li></ul><pre><code>docker build -t webcentos:v1 .   # . 是Dockerfile文件的路径，不能忽略docker images                    #查看是否创建成功docker run –d webcentos:v1       #后台运行容器docker ps                        #查看当前运行中的容器docker ps –a                     #查看所有容器，包括未运行中的docker logs CONTAINER ID/IMAGE   #如未查看到刚才运行的容器，则用容器id或者名字查看启动日志排错docker commit fb2844b6c070 dtstackweb:v1 #commit 后接容器id 和构建新镜像的名称和版本号。docker images                    #列出本地（已下载的和本地创建的）镜像docker push                      #将镜像推送至远程仓库，默认为 Docker Hub</code></pre><ul><li>将镜像推送到registry</li></ul><pre><code>docker login --username=dtstack_plus registry.cn-shanghai.aliyuncs.com #执行后输入镜像仓库密码docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/dtstack123/test:[镜像版本号]docker push registry.cn-shanghai.aliyuncs.com/dtstack123/test:[镜像版本号]</code></pre><blockquote><p>其中<strong>ImageId</strong>和<strong>镜像版本号</strong>请您根据自己的镜像信息进行填写。</p></blockquote><p>在镜像仓库能查看到镜像版本信息则说明推送成功。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片格式( SVG | WebP)</title>
      <link href="/2020/02/23/2020/0223/tu-pian-ge-shi/"/>
      <url>/2020/02/23/2020/0223/tu-pian-ge-shi/</url>
      
        <content type="html"><![CDATA[<p>SVG 和 WebP图片优缺点和适用范围，SVG适合做图标或者颜色变化不大的图片，WebP可以不降低质量的情况将资源降到比较低，适合做App瘦身。</p><h3 id="WebP简介"><a href="#WebP简介" class="headerlink" title="WebP简介"></a>WebP简介</h3><p><strong>WebP</strong>是谷歌提供的一种支持有损压缩和无损压缩的图片文件格式，而且可以提供比JPEG或PNG更好的压缩。</p><blockquote><p>在Android 4.0(API level 14)中支持有损的WebP图像</p><p>在Android 4.3(API level 18)和更高版本中支持无损和透明的WebP图像</p><p><strong>所以建议您的项目必须声明一个minSdkVersion 18或更高版本</strong></p></blockquote><h3 id="两者的优点"><a href="#两者的优点" class="headerlink" title="两者的优点"></a>两者的优点</h3><h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><ul><li>尺寸小, 压缩性强;</li><li>矢量图片;</li><li>XML编写;</li><li>图片内文字支持搜索, Web端适用;</li></ul><h4 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h4><ul><li>精细度不降低的前提下缩小图片体积;</li></ul><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><h4 id="SVG-1"><a href="#SVG-1" class="headerlink" title="SVG"></a>SVG</h4><ul><li>Web端: IE9开始兼容;</li><li>Android: 安卓3.X开始局部支持;</li><li>IOS: Safari简单支持, 复杂滤镜不可行;</li></ul><h4 id="WebP-1"><a href="#WebP-1" class="headerlink" title="WebP"></a>WebP</h4><ul><li>Web端: Chromium内核浏览器, 国内占比50%;</li><li>Android: 支持 ( Android4.0以上提供的原生支持, 4.0以下使用官方解析库) ;</li><li>IOS: 使用官方解析库;</li></ul><h3 id="图片大小"><a href="#图片大小" class="headerlink" title="图片大小"></a>图片大小</h3><h4 id="例子图片，转换后："><a href="#例子图片，转换后：" class="headerlink" title="例子图片，转换后："></a>例子图片，转换后：</h4><ul><li>转换为PNG后, 2.3M, 124K ;</li><li>转换为SVG后, 1.44M, 257K ; 有细微失真 ;</li><li>转换为WebP后, 91.5K, 16.3K ; 没有失真 ;</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过自己测试的两张图片, </p><ul><li><p>发现目前SVG更适合做图标, </p></li><li><p>色彩变化较为精细的图片转化为SVG格式后会变得更大，不太适合 ; </p></li><li><p>而WebP暂时没有发现什么弊端.</p></li></ul><blockquote><p>PS: 现在可以使用AndroidStudio直接转化webP, AS真乃亲爸</p></blockquote><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p><a href="https://isux.tencent.com/why-svg.html" target="_blank" rel="noopener">SVG</a></p></li><li><p><a href="https://isux.tencent.com/introduction-of-webp.html" target="_blank" rel="noopener">WebP</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多媒体 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github项目批量抓取</title>
      <link href="/2020/02/22/2020/0222/github-xiang-mu-pi-liang-zhua-qu/"/>
      <url>/2020/02/22/2020/0222/github-xiang-mu-pi-liang-zhua-qu/</url>
      
        <content type="html"><![CDATA[<p>有时候我们同步Github的项目时候，每次单个项目pull很麻烦，最终发现可以通过python3的脚步完成多个项目同步完成。</p><h1 id="首先安装"><a href="#首先安装" class="headerlink" title="首先安装"></a>首先安装</h1><ul><li>安装批量工具<pre><code>pip install ghcloneall</code></pre><h1 id="其次编辑"><a href="#其次编辑" class="headerlink" title="其次编辑"></a>其次编辑</h1></li><li>ROI_Origanizations格式说明<pre><code>vim ROI_Organizations.md</code></pre><blockquote><p>[OrgName] [u|o]<br>u 代表 OrgName 为用户<br>o 代表 OrgName 为 Organization</p></blockquote></li></ul><h1 id="然后抓取"><a href="#然后抓取" class="headerlink" title="然后抓取"></a>然后抓取</h1><ul><li>脚步执行命令<pre><code>python3 GitCrawler.py</code></pre><blockquote><p>参考安装链接：<a href="https://github.com/carywei/GitCrawler" target="_blank" rel="noopener">https://github.com/carywei/GitCrawler</a></p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年第一天班</title>
      <link href="/2020/02/03/2020/0203/2020-nian-di-yi-tian-ban/"/>
      <url>/2020/02/03/2020/0203/2020-nian-di-yi-tian-ban/</url>
      
        <content type="html"><![CDATA[<p>现在是晚上2020-02-30 06:26 我在内蒙古赤峰旺业甸服务区，由于下雪高速封路，我们在高速入口处等待高速封路解除，与工作人员沟通预计上午10点可以通行。</p><h2 id="现在所想"><a href="#现在所想" class="headerlink" title="现在所想"></a>现在所想</h2><h3 id="聊聊BYD秦续航"><a href="#聊聊BYD秦续航" class="headerlink" title="聊聊BYD秦续航"></a>聊聊BYD秦续航</h3><ul><li>标准里程表显示400公里</li><li>夏天实际行驶预计在360公里，因为剩下40公里需要找充电桩，呵呵。</li><li>冬天实际行驶预计在200公里，因为天气冷的原因，电池能耗比较低。</li></ul><h3 id="目的北京"><a href="#目的北京" class="headerlink" title="目的北京"></a>目的北京</h3><pre><code>* 途径矛荆坝服务区* 途径安子岭服务区* 途径太师屯服务区</code></pre><h3 id="抵达北京家中封闭"><a href="#抵达北京家中封闭" class="headerlink" title="抵达北京家中封闭"></a>抵达北京家中封闭</h3><pre><code>* 备了很多面条* 备了不少蘑菇酱* 备了一些萝卜</code></pre><h3 id="期望今年能够平稳度过"><a href="#期望今年能够平稳度过" class="headerlink" title="期望今年能够平稳度过"></a>期望今年能够平稳度过</h3><pre><code>* 工作顺利* 完成业绩* 突破自我* 自我卓越</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Hello World</title>
      <link href="/2019/12/24/2019/1224/hello-world/"/>
      <url>/2019/12/24/2019/1224/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
